#+PROPERTY: header-args :tangle yes :comments both :results silent
#+PROPERTY: header-args:elisp :lexical t

* Package header
#+begin_src elisp :comments no
  ;;; majjik.el --- Magit-inspired jujutsu interface for Emacs  -*- lexical-binding: t -*-

  ;; Copyright (C) 2026 Zoey Hewll

  ;; Author: Zoey Hewll <zoeyhewll@gmail.com>
  ;; Created: 02 Jan 2026
  ;; Version: 0.1.0
  ;; Keywords: vc
  ;; URL: https://github.com/Zoybean/majjik
  ;; Package-Requires: (dash s eieio with-editor)

  ;;; Commentary:
  
  ;;; Code:
#+end_src

* Require
#+begin_src elisp
  (require 'dash)
  (require 's)
  (require 'eieio)
  (require 'with-editor)
#+end_src
* Utils

** macros
*** collect-repeat
#+begin_src elisp
  (defmacro collect-repeat (&rest body)
    "Call FN repeatedly until it returns nil. Return the list of non-nil values."
    (let ((vals-sym (gensym "vals")))
      `(let ((,vals-sym))
         (while-let ((val (progn ,@body)))
           (push val ,vals-sym))
         (nreverse ,vals-sym))))

  (ert-deftest jj-test-collect-repeat ()
    (should (eq nil
                (collect-repeat nil)))
    (should (equal '(2 1 0)
                   (let ((x 3))
                     (collect-repeat (when (< 0 x)
                                       (cl-decf x)))))))
#+end_src
*** error-context
#+begin_src elisp
  (defmacro with-error-context (formatter-fn &rest body)
    "If BODY signals an error condition, modify its message by calling FORMATTER-FN on the original message. FORMATTER-FN should take and return a string."
    (declare (indent 1))
    `(handler-bind ((error (lambda (err)
                             (cl-callf ,formatter-fn
                                 (cadr err)))))
       (progn ,@body)))

  (defmacro with-error-format (format-str &rest body)
    "If BODY signals an error condition, reformat the original message by calling `format' with FORMAT-STR and the original message."
    (declare (indent 1))
    `(with-error-context (lambda (msg) (format ,format-str msg))
       ,@body))
#+end_src
*** let-match
#+begin_src elisp
  (defmacro let-match (spec-list &rest body)
    "Bind SPEC-LIST to the numbered matching groups, and execute BODY.

  SPEC-LIST is of a form similar to let.  For example:
    ((VAR1 GROUP1)
     (VAR2)
     VAR3
     (VAR4 GROUP4))

  Where each VAR is the local variable, and each GROUP is a numeric literal or variable specifying a matching group in the current match data. If any GROUP is nil or unspecified, count up from the last number, or from 1."
    (declare (indent 1))
    `(let ,(cl-loop for last-num = 0 then num
                    for spec in spec-list
                    for (name num) = (pcase spec
                                       (`(,name ,num)
                                        spec)
                                       ((or `(,name) name)
                                        `(,name ,(1+ last-num))))
                    collect `(,name (match-string ,num)))
       ,@body))

  (defmacro let-match-string (spec-list string &rest body)
    "Bind SPEC-LIST to the numbered matching groups in STRING, and execute BODY.

  SPEC-LIST is of a form similar to let.  For example:
    ((VAR1 GROUP1)
     (VAR2)
     VAR3
     (VAR4 GROUP4))

  Where each VAR is the local variable, and each GROUP is a numeric literal or variable specifying a matching group in the current match data. If any GROUP is nil or unspecified, count up from the last number, or from 1."
    (declare (indent 2))
    `(let ,(cl-loop for last-num = 0 then num
                    for spec in spec-list
                    for (name num) = (pcase spec
                                       (`(,name ,num)
                                        `(,name ,(or num (1+ last-num))))
                                       ((or `(,name) name)
                                        `(,name ,(1+ last-num))))
                    collect `(,name (match-string ,num ,string)))
       ,@body))

  (ert-deftest jj-test-let-match-string ()
    (should (string-match (rx (group "f" anychar anychar)
                      " "
                      (group (+ (not (any " "))))
                      " "
                      (group "baz"))
                          "foo bar baz"))
    (let-match-string ((foo 1)
                       (bar 2)
                       (baz 3))
        "foo bar baz"
      (should (equal (list foo bar baz)
                     (list "foo" "bar" "baz")))))

  (ert-deftest jj-test-let-match-string-elided ()
    (should (string-match (rx (group "f" anychar anychar)
                      " "
                      (group (+ (not (any " "))))
                      " "
                      (group "baz"))
                          "foo bar baz"))
    (let-match-string ((foo)
                       (bar)
                       (baz))
        "foo bar baz"
      (should (equal (list foo bar baz)
                     (list "foo" "bar" "baz")))))

  (ert-deftest jj-test-let-match-string-flat ()
    (should (string-match (rx (group "f" anychar anychar)
                      " "
                      (group (+ (not (any " "))))
                      " "
                      (group "baz"))
                          "foo bar baz"))
    (let-match-string (foo
                       bar
                       baz)
        "foo bar baz"
      (should (equal (list foo bar baz)
                     (list "foo" "bar" "baz")))))

  (ert-deftest jj-test-let-match-string-disordered ()
    (should (string-match (rx (group "f" anychar anychar)
                      " "
                      (group (+ (not (any " "))))
                      " "
                      (group "baz"))
                          "foo bar baz"))
    (let-match-string ((bar 2)
                       baz ;; same as (baz 3)
                       (foo 1))
        "foo bar baz"
      (should (equal (list foo bar baz)
                     (list "foo" "bar" "baz")))))

#+end_src
*** opt
#+begin_src elisp
  (defun opt (&optional item)
    "Helper for splicing optional items into backquoted lists.

  Use me with comma-at!"
    (when item `(,item)))
#+end_src

** argument utils
#+begin_src elisp
  (defun jj--quote-argument (name)
    "Return NAME in double-quotes, with nested double-quotes and backslashes escaped."
    (format "\"%s\""
            (replace-regexp-in-string
             ;; I think the only special characters for jj
             ;; that function in inner double-quotes
             ;; are the quote and the escape itself
             (rx (any ?\" ?\\))
             "\\\\\\&" name)))

  (defun jj--toml-quote-string (str)
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (cl-loop while (re-search-forward (rx (any control)) nil :noerr)
               for old = (aref (match-string 0) 0)
               do (replace-match (format "\\x%02x" old) nil :literal))
      (buffer-string)))

  (defun jj--if-arg (arg formatter &optional flag)
    "Helper for building command-line arguments.

  If ARG is nil, returns nil. Otherwise returns the list containing FLAG (if provided) and the result of calling FORMATTER on argument ARG. If formatter is nil or returns nil, the ARG is omitted from the return value."
    (and arg
         `(,@(opt flag)
           ,@(opt (and formatter
                       (funcall formatter arg))))))

  (ert-deftest jj--test-if-arg ()
    (should (equal `("--" "foo-bar")
                   (jj--if-arg "foo"
                               (lambda (x)
                                 (format "%s-bar" x))
                               "--")))
    (should (equal `()
                   (jj--if-arg nil
                               (lambda (x)
                                 (error "should not be called for nil arg"))
                               "--")))
    (should (equal `("foo-bar")
                   (jj--if-arg "foo"
                               (lambda (x)
                                 (format "%s-bar" x)))))
    (should (equal `("--no-args-flag")
                   (jj--if-arg t
                               #'ignore
                               "--no-args-flag")))
    (should (equal `("--no-args-flag")
                   (jj--if-arg t
                               nil
                               "--no-args-flag"))))
#+end_src

** process utils

*** sync processes
#+begin_src elisp
  (defun call-cmd (cmd &optional infile destination display noerror)
    "Call CMD via `call-process', with some changes.
  If DESTINATION is `:string', include the program output in the return value and any error messages, and ignore DISPLAY.
  If NOERROR is nil and the process has a nonzero exit code, signal an error, citing the exit code.
  If NOERROR is non-nil, include the exit code in the return value.
  When returning both a string result and an exit code, they are returned as a cons (CODE . OUTPUT)."
    (pcase destination
      (:string
       (let ((dir default-directory))
         (with-temp-buffer
           (-let* ((default-directory dir)
                   ((prog . args) cmd)
                   (res (apply #'call-process prog infile t nil args))
                   (out (buffer-string)))
             (if noerror
                 (cons res out)
               (unless (= res 0)
                 (error "process exited with nonzero exit code %d: %s" res out))
               out)))))
      (_
       (-let* (((prog . args) cmd)
               (res (apply #'call-process prog infile destination display args)))
         (if noerror
             res
           (unless (= res 0)
             (error "process exited with nonzero exit code %d" res)))))))
#+end_src
*** async processes
#+begin_src elisp
  (defun jj--make-process-log-section-buffers (name cmd)
    "Return a triple of buffers (CODE STDOUT . STDERR) for indirectly writing to the jj log buffer for the current repo. CODE contains the process status info, and STDOUT and STDERR the respective streams.
  Also sets up folding so that TAB anywhere within a command will toggle the display of the full log."
    (let ((repo-dir default-directory))
      (with-current-buffer (jj--get-command-log-buf repo-dir)
        (goto-char (point-max))
        (let* ((inhibit-read-only t)
               (mark-control-start (point-marker))
               (code-buf (jj-make-section-buffer name "(" ") "))
               (header (concat "> " (mapconcat #'shell-quote-argument
                                               `("jj" ,@jj-global-default-args ,@cmd) " ")))
               (header-end
                (progn
                  (insert (propertize header 'face 'magit-section-heading))
                  (point-marker)))
               (stdout (jj-make-section-buffer name "\n" "\n"))
               (mark-err-start (point-marker))
               (stderr (jj-make-section-buffer name (propertize "\n" 'face 'magit-section-heading) "\n"))
               (mark-collapse-end (copy-marker (point-max)))
               (mark-control-end (progn
                                   (goto-char (point-max))
                                   (insert "\n")
                                   (copy-marker (point))))
               ;; this needs to be an overlay,
               ;; so we can toggle its properties as a unit
               (ovl-collapse (make-overlay header-end mark-collapse-end))
               ;; these two also need to be overlays,
               ;; so they keep applying as text is added
               (ovl-err (make-overlay mark-err-start mark-collapse-end))
               (ovl-control (make-overlay mark-control-start mark-control-end)))
          (overlay-put ovl-collapse 'display "...")
          (overlay-put ovl-err
           'face '(:foreground "grey"))
          (overlay-put ovl-control
           'keymap (jj--make-toggle-keymap
                    (jj--make-toggle-overlay-ellipsis ovl-collapse "...")))
          `(,code-buf ,stdout . ,stderr)))))

  (defun jj--make-toggle-keymap (toggle-fn)
    "Make a keymap that binds TAB to TOGGLE-FN."
    (let ((map (make-sparse-keymap)))
      (keymap-set map "TAB" toggle-fn)
      map))

  (defun jj--make-toggle-overlay-ellipsis (overlay string)
    "Make a function that toggles the display property of OVERLAY between nil and STRING."
    (lambda ()
      (interactive)
      (overlay-put overlay 'display
                   (if (overlay-get overlay 'display)
                       nil
                     string))))

  (defun jj--set-initial-run-status (code-buf)
    (with-current-buffer code-buf
      (let ((inhibit-read-only t))
        (replace-region-contents
         (point-min) (point-max)
         (lambda () (propertize "run" 'face '(:foreground "yellow")))))))

  (defun jj--make-update-exit-code-sentinel (code-buf)
    "Process sentinel to update the contents of CODE-BUF (a buffer) with the exit status of the process."
    (lambda (proc event)
      (with-current-buffer code-buf
        (let ((inhibit-read-only t))
          (replace-region-contents
           (point-min) (point-max)
           (lambda ()
             (cond ((process-live-p proc)
                    ;; process is still running
                    ;; what's it doing?
                    (propertize
                     (format "%s" (process-status proc))
                     'face `(:foreground
                             "yellow")))
                   (t
                    ;; process is done. how'd it exit?
                    (let ((code (process-exit-status proc)))
                      (propertize
                       (format "%d" code)
                       'face `(:foreground
                               ,(pcase code
                                  (0 "green")
                                  (_ "red")))))))))))))

  (defun jj--sticky-insert (marker insert-fn sticky-top)
    "Move to MARKER, call INSERT-FN, update the marker, and move point if it's at the marker. If STICKY-TOP and point is at the beginning of the buffer, it will not move even if it is at the marker."
    (let ((moving (and (= (point) marker)
                       (not (and sticky-top (bobp))))))
      (save-excursion
        (goto-char marker)
        (let ((inhibit-read-only t))
          (funcall insert-fn))
        (set-marker marker (point)))
      (when moving (goto-char marker))))

  (defun make-sticky-process-filter (&optional initially-stay)
    "Make a process filter that outputs to buffer without moving point.
  If INITIALLY-STAY is non-nil, point stays in place if it is at `bobp' even if this is also the position of the `process-mark'"
    (lambda (proc string)
      (:documentation (format "Process filter that outputs to buffer without moving point. If point %s, it follows the insertion. Otherwise it stays in place."
                              (if initially-stay
                                  "is at the position that text is inserted, and is not at the beginning of the buffer"
                                "is at the position that text is inserted")))
      (when (buffer-live-p (process-buffer proc))
        (with-current-buffer (process-buffer proc)
          (jj--sticky-insert (process-mark proc)
                             (lambda () (insert string))
                             initially-stay)))))

  (defun jj--make-print-status-sentinel (buffer)
    (lambda (proc event)
      (unless (process-live-p proc)
        (when (buffer-live-p buffer)
          (unless (= (process-exit-status proc) 0)
            ;; exited abnormally
            (with-current-buffer buffer
              (goto-char (point-max))
              ;; add error status to error buffer
              (let ((inhibit-read-only t))
                (unless (bolp)
                  (insert "\n"))
                (insert
                 (propertize event 'face '(:foreground "red"))
                 "\n"))))))))

  (defun jj--make-cleanup-sentinel (&rest buffers)
    "Kill BUFFERS if process is no longer live."
    (lambda (proc event)
      (unless (process-live-p proc)
        (mapcar #'kill-buffer buffers))))

  (defun make-jj-simple-sentinel (error-buffer &rest other-buffers)
    "Make a simple process sentinel, to insert ERROR-BUFFER's contents if the process ends unexpectedly, then kill it and all OTHER-BUFFERS."
    (let ((status (jj--make-print-status-sentinel error-buffer))
          (cleanup (apply #'jj--make-cleanup-sentinel error-buffer other-buffers)))
      (lambda (proc event)
        (funcall status proc event)
        (funcall cleanup proc event))))

  (defun make-jj-callback-sentinel (end-callback)
    "Make a simple process sentinel, to call END-CALLBACK with 2 arguments: the exit code and end event."
    (lambda (proc event)
      (funcall end-callback
               (process-exit-status proc)
               event)))

  (defun make-jj-generic-buffered-filter (intermediate-buffer read-next callback)
    "Make a process filter for an arbitrary process.
  Every time there is new output, the filter adds it to the INTERMEDIATE-BUFFER, then calls READ-NEXT from the buffer beginning until it returns nil, then calls CALLBACK with the list of new non-nil values, and deletes the text before point (i.e. the text that was read).

  READ-NEXT should be a function that reads forward from `point', and moves `point' past whatever has been read.
  CALLBACK should be a function of one argument - the list of non-nil values returned by READ-NEXT."
    (lambda (proc string)
      (:documentation (format "This filter adds output to its intermediate buffer, then calls `%s' until it returns nil, then calls `%s' with the list of new non-nil values, and deletes the text before point (i.e. the text that was read)." read-next callback))
      (when (buffer-live-p (process-buffer proc))
        (with-current-buffer intermediate-buffer
          (insert string)
          ;; process any new entries
          (save-excursion
            (goto-char (point-min))
            ;; check if we have any new full entries in the buffer
            (when-let ((news (collect-repeat (funcall read-next))))
              ;; delete them and send the list to the callback
              (funcall callback news)
              (delete-region (point-min) (point))))))))
#+end_src

** log utils
#+begin_src elisp
  (defun jj-partition-runs (list &optional test)
    "Split LIST into segments where either all elements are equal, or no consecutive elements are equal, using function TEST to compare for equality, or `eq' if not provided."
    (let ((parts)
          (running)
          (test (or test #'eq)))
      (cl-labels ((run (x)
                    ;; start or add to a run
                    (cond ((and parts
                                ;; check that it's *the same run*, and not a distinct but consecutive run
                                (funcall test (caar parts) x)
                                running)
                           ;; add to the last part
                           (push x (car parts))
                           )
                          (t
                           ;; make a new part
                           (push (list x)
                                 parts)
                           (setq running t))))
                  (end (x)
                    ;; start or add to a non-run
                    (cond ((and parts
                                (not running))
                           ;; add to the last part
                           (push x (car parts)))
                          (t
                           ;; make a new part
                           (push (list x)
                                 parts)
                           (setq running nil)))))
        (cl-loop for place on list
                 for first = t then nil
                 do (pcase-exhaustive place
                      (`(,_ . nil))
                      ((and `(,a ,b . ,_)
                            (guard (funcall test a b)))
                       (when first
                         (run a))
                       (run b))
                      ((and `(,a ,b ,c . ,_)
                            (guard (funcall test b c)))
                       (when first
                         (end a))
                       (run b))
                      (`(,a ,b . ,_)
                       (when first
                         (end a))
                       (end b)))
                 finally return (nreverse (mapcar #'nreverse parts))))))

  (ert-deftest jj-test-partition-runs ()
    "Check that `jj-partition-runs' gives expected results for all 4-tuples with `eq'."
    (cl-loop for (set . exp) in '(((a b c d) (a b c d))
                                  ((a a b c) (a a) (b c))
                                  ((a b b c) (a) (b b) (c))
                                  ((a b c c) (a b) (c c))
                                  ((a a b b) (a a) (b b))
                                  ((a a a b) (a a a) (b))
                                  ((a b b b) (a) (b b b)))
             collect (should (equal exp
                                    (jj-partition-runs set)))))
  (ert-deftest jj-test-partition-runs-strings ()
    "Check that `jj-partition-runs' gives expected results for all 4-tuples with a test function."
    (cl-loop for (set . exp) in '((("a" "b" "c" "d") ("a" "b" "c" "d"))
                                  (("a" "a" "b" "c") ("a" "a") ("b" "c"))
                                  (("a" "b" "b" "c") ("a") ("b" "b") ("c"))
                                  (("a" "b" "c" "c") ("a" "b") ("c" "c"))
                                  (("a" "a" "b" "b") ("a" "a") ("b" "b"))
                                  (("a" "a" "a" "b") ("a" "a" "a") ("b"))
                                  (("a" "b" "b" "b") ("a") ("b" "b" "b")))
             collect (should (equal exp
                                    (jj-partition-runs set #'string=)))))
#+end_src

** regex and reader utils
#+begin_src elisp
  (defun jj--re-step-over (regexp &optional bound no-error)
    "Like `re-search-forward' but the match-start must be point. Like `looking-at' but moves point."
    (if-let* ((matched (looking-at regexp))
              (end (match-end 0))
              (ok (or (not bound)
                      (<= end bound))))
        (prog1 ok
          (goto-char end))
      (unless no-error
        (error "anchored search failed: %s" regexp))))

  (defun jj--forgiving-read (reader)
    "Call READER, and ignore errors. If it fails, reset point."
    (let ((marker))
      (prog1
          (save-excursion
            (condition-case e
                (funcall reader)
              (error ())
              ;; set the marker because we succeeded.
              ;; we need a marker to save the position for after the save-excursion.
              (:success
               ;; return the original result
               (prog1 e
                 (setq marker (point-marker))))))
        (when marker
          (goto-char marker)))))
  
  (defun jj--try-read-each (&rest readers)
    "Try each of READERS until one returns non-nil. Each call to a reader is wrapped in `jj--forgiving-read', resetting point on failure."
    (cl-loop for reader in readers
             for val = (jj--forgiving-read reader)
             when val return val
             finally return nil))
#+end_src

** json utils
#+begin_src elisp
(defun jj--parse-json-entire-string (string)
  "Parse a json object that is the entirety of STRING (besides whitespace)."
  (with-temp-buffer
    (save-excursion (insert (string-trim string)))
    (prog1 (json-read)
      (unless (eobp)
        (error "string did not wholly encode a single json object: %s" string)))))
#+end_src

** rendering utils
#+begin_src elisp
  (defun erase-accessible-buffer ()
    ;; erase while respecting narrowing
    (delete-region (point-min) (point-max)))

  (defun replace-buffer-contents-and-properties (source &optional max-secs max-costs)
    (let ((buf (current-buffer)))
      (replace-buffer-contents source max-secs max-costs)
      (with-current-buffer source
        (cl-loop for start = (point-min) then pos
                 for pos = (next-property-change start)
                 for end = (or pos
                               (point-max))
                 for props = (text-properties-at start)
                 do (set-text-properties start end props buf)
                 while pos))))

  (defun jj--entitize-newlines (string)
    "Propertize all newlines in STRING with the corresponding escape glyph, with the `escape-glyph' face."
    (let* ((replacements `(("\n" . "^J")
                           ("\r" . "^M"))))
      (replace-regexp-in-string
       (regexp-opt (mapcar 'car replacements))
       (lambda (it)
         (let ((rep (s--aget replacements it)))
           (propertize it
                       'display rep
                       'face 'escape-glyph)))
       string t t)))

  (ert-deftest jj-test-entitize-newlines ()
    (should (string= "foo\r\nbar"
                     (jj--entitize-newlines "foo\r\nbar"))))
#+end_src

* DSLs
** Fileset
#+begin_src elisp
  (defun jj-files-as-fileset (&rest files)
    "Returns a fileset that matches all the given FILES. No globbing is applied, and all are considered relative to cwd."
    (jj-fileset `(or ,@(cl-loop for file in files
                                collect `(:cwd-file ,file)))))

  (defmacro jj-compile-fileset (sexp)
    "Compile a fileset SEXP into a string suitable for use as a jj fileset argument. See `jj-fileset'"
    (jj-fileset sexp))

  (defun jj-fileset (sexp)
    "Convert a fileset SEXP into a string suitable for use as a jj fileset argument.
  Operators and patterns are called as lisp functions.
  Operators are `and', `or' and `not'.
  Patterns all have keyword names, and all keywords are assumed to be patterns.
  See URL `https://docs.jj-vcs.dev/latest/filesets/' for more info."
    (cl-labels ((render-unpack (sexp)
                  (pcase (render sexp)
                    ((or `(form)
                         form)
                     (format "%s" form))
                    (unrecognised
                     (error "inner fileset render call produced invalid result: %S" unrecognised))))
                (render-str (sexp)
                  (format "%s" (render sexp)))
                (render (sexp)
                  (pcase sexp
                    ;; file patterns: bare path
                    ((and path (pred stringp))
                     (jj--quote-argument path))
                    ;; file patterns: flag and path/glob
                    (`(,(and flag
                             (pred keywordp))
                       ,(and arg (pred stringp)))
                     (format "%s:%s"
                             (substring (symbol-name flag) 1)
                             (jj--quote-argument arg)))
                    ;; identity operators
                    (`(,(or 'or
                            'and)
                       ,form)
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (render form))
                    ;; operators: or, none (empty sum)
                    ((or `(or)
                         `(none))
                     "none()")
                    (`(or . ,forms)
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (list (mapconcat #'render-str forms "|")))
                    ;; operators: not
                    (`(not ,form)
                     (format "~%s"
                             (render form)))
                    ;; operators: and, all (empty product)
                    ((or `(and)
                         `(all))
                     "all()")
                    ;; both shorthands for "A and not B"
                    ((or `(and ,form (not ,form-neg))
                         `(and (not ,form-neg) ,form))
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (list (format "%s~%s"
                                   (render form)
                                   (render form-neg))))
                    (`(and . ,forms)
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (list (mapconcat #'render-str forms "&")))
                    (unknown (user-error "Unknown fileset operator form: %S" unknown)))))
      (render-unpack sexp)))

  (ert-deftest jj--test-render-fileset ()
    (should (string=
             ;; using format here to do the extra quoting for me.
             ;; the argument to format is what you'd type at the console.
             "\"foo\""
             (jj-fileset "foo")))

    ;; optimisation: top-level parens are elided
    (should (string=
             "glob:\"foo/**\"|\"bar\""
             (jj-fileset '(or (:glob "foo/**") "bar"))))
    (should (string=
             "~glob:\"foo/**\"|\"bar\""
             (jj-fileset '(or (not (:glob "foo/**")) "bar"))))

    ;; optimisations: (A) and (not B) => (A)~(B)
    ;; optimisations: (not B) and (A) => (A)~(B)
    (should (string=
             "\"bar\"~glob:\"foo/**\""
             (jj-fileset '(and "bar" (not (:glob "foo/**"))))))
    (should (string=
             "\"bar\"~glob:\"foo/**\""
             (jj-fileset '(and (not (:glob "foo/**")) "bar"))))

    ;; metacharacters are quoted
    (should (string=
             "\"~/path/under/home\""
             (jj-fileset "~/path/under/home")))
    (should (string=
             "\"'single-quoted-name'\""
             (jj-fileset "'single-quoted-name'"))))
#+end_src
** Revset
#+begin_src elisp
  (defun jj-revs-as-revset (&rest revs)
    "Returns a revset that matches all the given REVS. No globbing is applied, and all are considered relative to cwd."
    (jj-revset `(or ,@revs)))

  (defmacro jj-compile-revset (sexp)
    "Compile a revset SEXP into a string suitable for use as a jj revset argument. See `jj-revset'"
    (jj-revset sexp))

  (defun jj-revset (sexp)
    "Convert a revset SEXP into a string suitable for use as a jj revset argument.
  Operators, functions, and patterns are called as lisp functions.
  Operators are `and', `or', `not', `-', `+', `::', `..'. One-sided and no-sided versions of `::' and `..' are achieved with the placeholder symbol `_'.
  Patterns all have keyword names, and `::' is the only keyword not assumed to be a pattern.
  Any unrecognised names are assumed to be functions and aliases.
  See URL `https://docs.jj-vcs.dev/latest/revsets/' for more info."
    (let ((infix '(:: ..))
          (suffix '(- +))
          (prefix '(~)))
    (cl-labels ((render-unpack (sexp)
                  (pcase (render sexp)
                    ((or `(,form)
                         form)
                     (format "%s" form))
                    (unrecognised
                     (error "inner revset render call produced invalid result: %S" unrecognised))))
                (render-str (sexp)
                  (format "%s" (render sexp)))
                (render (sexp)
                  (pcase sexp
                      ;; operators: infix
                      (`(,(and op (guard (memq op infix))) . ,rest)
                       (list (pcase rest
                               ((or `(_ _) `(_) `())
                                (format "%s"
                                        op))
                               ((or `(,l _) `(,l))
                                (format "%s%s"
                                        (render l)
                                        op))
                               (`(_ ,r)
                                (format "%s%s"
                                        op
                                        (render r)))
                               (`(,l ,r)
                                (format "%s%s%s"
                                        (render l)
                                        op
                                        (render r)))
                               (unrecognised (error "invalid operands to %s: %S" op unrecognised)))))
                      ;; operators: suffix
                      (`(,(and op (guard (memq op suffix))) ,arg)
                       (format "%s%s" arg op))
                      ;; operators: prefix
                      (`(,(and op (guard (memq op prefix))) ,arg)
                       (format "%s%s" op arg))
                      ;; numbers
                    ((and num (pred numberp))
                     num)
                    ;; string patterns: bare path
                    ((and path (pred stringp))
                     (jj--quote-argument path))
                    ;; string patterns: flag and path/glob
                    (`(,(and flag
                             (pred keywordp))
                       ,(and arg (pred stringp)))
                     (format "%s:%s"
                             (substring (symbol-name flag) 1)
                             (jj--quote-argument arg)))
                      ;; operator aliases
                      (`(parents ,form)
                       (render `(- ,form)))
                      (`(children ,form)
                       (render `(+ ,form)))
                      (`(descendants ,form)
                       (render `(:: ,form _)))
                    ((or `(non-ancestors ,form)
                           `(not (ancestors ,form)))
                       (render `(.. ,form _)))
                      (`(ancestors ,form)
                       (render `(:: _ ,form)))
                      ;; operators: singleton and/or (identity)
                      (`(,(or 'or 'and) ,form)
                       (render form))
                      ;; operators: empty or (empty sum = none)
                    ((or `(or)
                         `(none))
                     "none()")
                    (`(or . ,forms)
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (list (mapconcat #'render-str forms "|")))
                    ;; operators: not
                    (`(not ,form)
                     (format "~%s"
                             (render form)))
                      ;; operators: empty and (empty product = all)
                    ((or `(and)
                         `(all))
                     "all()")
                    ;; both shorthands for "A and not B"
                    ((or `(and ,form (not ,form-neg))
                         `(and (not ,form-neg) ,form))
                     (list (format "%s~%s"
                                   (render form)
                                   (render form-neg))))
                    (`(and . ,forms)
                     ;; trick to only nest in quotes if an outer form requires it
                     ;; outermost caller will unwrap any toplevel list
                     (list (mapconcat #'render-str forms "&")))
                    ;; functions
                    (`(,(and fun (pred symbolp)) . ,args)
                     (format "%s(%s)" fun (mapconcat #'render-unpack args ",")))
                    ;; assume anything else is an alias
                    (alias alias)
                    ;; this will never occur with the alias catch-all
                    ;; still leaving in in-case i remove the catch-all
                    (unknown (user-error "Unknown revset operator form: %S" unknown)))))
        (render-unpack sexp))))

  (ert-deftest jj--test-render-revset ()
    (should (string=
             "\"foo\""
             (jj-revset "foo")))

    ;; optimisation: top-level parens are elided
    (should (string=
             "glob:\"foo*\"|\"bar\""
             (jj-revset '(or (:glob "foo*") "bar"))))
    (should (string=
             "~glob:\"foo*\"|\"bar\""
             (jj-revset '(or (not (:glob "foo*")) "bar"))))

    ;; optimisations: (A) and (not B) => (A)~(B)
    ;; optimisations: (not B) and (A) => (A)~(B)
    (should (string=
             "\"bar\"~glob:\"foo*\""
             (jj-revset '(and "bar" (not (:glob "foo*"))))))
    (should (string=
             "\"bar\"~glob:\"foo*\""
             (jj-revset '(and (not (:glob "foo*")) "bar"))))

    ;; metacharacters are quoted
    (should (string=
             "\"~/path/under/home\""
             (jj-revset "~/path/under/home")))
    (should (string=
             "\"'single-quoted-name'\""
             (jj-revset "'single-quoted-name'")))
    ;; [revset-aliases]
    ;; 'default_immutable_heads()'
    (should (string=
             "trunk()|tags()|untracked_remote_bookmarks()"
             (jj-revset '(or (trunk) (tags) (untracked_remote_bookmarks)))))

    ;; 'immutable_heads()'
    (should (string=
             "default_immutable_heads()|(working_copies()~@)"
             (jj-revset '(or (default_immutable_heads) (and (working_copies) (not @))))))

    ;; 'local()'
    (should (string=
             "~::remote_bookmarks()"
             (jj-revset '(:: ~ (remote_bookmarks)))))

    ;; 'limb()'
    ;; this could be optimised if the function knew about operator binding strength
    (should (string=
             "((::@)&local())::"
             (jj-revset '(descendants (and (ancestors @) (local))))))
    (should (string=
             "((::@)&local())::"
             (jj-revset '(:: (and (:: _ @) (local)) _))))

    ;; 'graft()'
    (should (string=
             "ancestors(limb(),2)"
             (jj-revset '(ancestors (limb) 2))))

    ;; 'relevant()'
    (should (string=
             "ancestors(local()|mutable(),2)|trunk()"
             (jj-revset '(or (ancestors (or (local) (mutable)) 2) (trunk)))))

    ;; 'leaves()'
    (should (string=
             "heads(mutable()|@)"
             (jj-revset '(heads (or (mutable) @))))))
#+end_src
** Template
#+begin_src elisp
  (defmacro jj-compile-template (sexp)
    "Compile a template SEXP into a string suitable for use as a jj template argument. See `jj-template'"
    (jj-template sexp))

  (defun jj-template (sexp)
    "Convert a template SEXP into a string suitable for use as a jj template argument.
  Operators, functions, methods, and patterns are called as lisp functions.
  Methods' names all begins with a `.'.
  Special form (:chain target (.method args...)...) can be used to chain multiple methods oo-style.
  Special form (:get target field) can be used to get a field (if jj ever adds that concept) of an object.
  Operators are `and' `or' `-' `!' `+' `*' `/' `%' `>=' `>' `<=' `<' `==' `!=' `&&' `||' `++'.
  Patterns all have keyword names, and `::' is the only keyword not assumed to be a pattern.
  Any unrecognised names are assumed to be functions and aliases.
  See URL `https://docs.jj-vcs.dev/latest/templates/' for more info."
    (let ((infix-2 '(< <= > >= == !=))
          (infix-2+ '(* / % + - || && ++))
          (prefix '(- !)))
      (cl-labels ((render-unpack (sexp)
                    (pcase (render sexp)
                      ((or `(,form)
                           form)
                       (format "%s" form))
                      (unrecognised
                       (error "inner template render call produced invalid result: %S" unrecognised))))
                  (render-str (sexp)
                    (format "%s" (render sexp)))
                  (render (sexp)
                    (pcase sexp
                      ;; special method call syntax. I'm basically implementing a macro here
                      (`(:chain ,(and target (pred symbolp)) . ,calls)
                       (render (cl-loop for call in calls
                                        for self = target then call-form
                                        for call-form = (pcase call
                                                          ;; method calls
                                                          (`(,(and
                                                               method
                                                               (pred symbolp)
                                                               (guard (string-prefix-p "." (symbol-name method))))
                                                             . ,(and args (pred listp)))
                                                           `(,method ,self . ,args))
                                                          ;; chained function calls
                                                          (`(,(and
                                                               function
                                                               (pred symbolp))
                                                             . ,(and args (pred listp)))
                                                           `(,function ,self . ,args))
                                                          ;; chained field access
                                                          ((and field (pred symbolp) (guard (string-prefix-p "." (symbol-name field))))
                                                           `(:get ,self ,field)))
                                        finally return call-form)))
                      ;; special field access syntax
                      (`(:get ,(and target (pred symbolp))
                              ,(and field (pred symbolp) (guard (string-prefix-p "." (symbol-name field)))))
                       (format "%s%s" target field))
                      ;; special syntax to embed a string template.
                      ;; vulnerable to bobby tables attacks - make sure it's a well-formed template before use
                      ;; nonetheless, wrapped in parens for some safety.
                      (`(:lit ,(and str (pred stringp)))
                       (list str))
                      ;; string literals
                      ((and str (pred stringp))
                       (jj--quote-argument str))
                      ;; number literals
                      ((and num (pred numberp))
                       num)
                      ;; lambdas
                      (`(lambda ,(and args (pred listp)) ,body-exp)
                       (list (format "|%s|%s"
                                     (mapconcat #'symbol-name args ",")
                                     (render-unpack body-exp))))
                      ;; operators: prefix
                      (`(,(and op (pred symbolp)
                               (guard (memq op prefix)))
                         ,arg)
                       (list (format "%s%s" op arg)))
                      ;; operators: infix-2
                      (`(,(and op (pred symbolp)
                               (guard (memq op infix-2)))
                         ,l ,r)
                       (list (format "%s%s%s"
                                     (render l)
                                     op
                                     (render r))))
                      ;; operators: infix-2+
                      (`(,(and op (pred symbolp)
                               (guard (memq op infix-2+)))
                         . ,(and args
                                 (guard (<= 2 (length args)))))
                       (list (mapconcat #'render-str args (symbol-name op))))
                      (`(,(and op (pred symbolp)
                               (guard (memq op infix-2+)))
                         . ,args)
                       (user-error "operator %s requires at least 2 operands, got %d: %s" op (length args) args))
                      ;; operators: or, false (empty sum)
                      ((or `(or)
                           'nil
                           'false)
                       "false")
                      (`(or . ,forms)
                       ;; trick to only nest in quotes if an outer form requires it
                       ;; outermost caller will unwrap any toplevel list
                       (list (mapconcat #'render-str forms "||")))
                      ;; operators: not
                      (`(not ,form)
                       (render `(! ,form)))
                      ;; operators: and, true (empty product)
                      ((or `(and)
                           't
                           'true)
                       "true")
                      (`(and . ,forms)
                       (list (mapconcat #'render-str forms "&&")))
                      (`(,(and method
                               (pred symbolp)
                               (guard (string-prefix-p "." (symbol-name method))))
                         ,self . ,args)
                       (format "%s%s(%s)"
                               (render self)
                               method
                               (mapconcat #'render-unpack args ",")))
                      (`(,(and function (pred symbolp)) . ,args)
                       (format "%s(%s)"
                               function
                               (mapconcat #'render-unpack args ",")))
                      ((and alias (pred symbolp)) alias)
                      (unknown (user-error "Unknown template operator form: %S" unknown)))))
        (render-unpack sexp))))

  (ert-deftest jj--test-render-template ()
    ;; infix
    (should (string=
             "commit_id++\" \"++change_id++\"\n\""
             (jj-template '(++ commit_id " " change_id "\n"))))
    ;; lambda
    (should (string=
             "parents.map(|c|c.commit_id().short()).join(\",\")"
             (jj-template '(.join (.map parents
                                        (lambda (c)
                                          (.short (.commit_id c))))
                                  ","))))
    ;; chain syntax
    (should (string=
             "parents.map(|c|c.commit_id().short()).join(\",\")"
             (jj-template '(:chain parents
                                   (.map 
                                    (lambda (c)
                                      (:chain c
                                              (.commit_id)
                                              (.short))))
                                   (.join ",")))))
    ;; chain syntax
    (should (string=
             "self.id().short()"
             (jj-template '(:chain self
                                   (.id)
                                   (.short)))))
    ;; chain non-method functions
    (should (string=
             "format_timestamp(self.committer().timestamp())"
             (jj-template '(:chain self (.committer) (.timestamp) (format_timestamp)))))

    ;; field syntax
    (should (string=
             "self.id.short()"
             (jj-template '(:chain self
                                   .id
                                   (.short)))))
    ;; function call
    (should (string=
             "coalesce(description,\"(no description set)\n\")"
             (jj-template '(coalesce description "(no description set)\n"))))

    ;; function call
    (should (string=
             "concat(format_field(\"Commit ID\",commit_id),format_field(\"Change ID\",change_id))"
             (jj-template '(concat (format_field "Commit ID" commit_id)
                                   (format_field "Change ID" change_id)))))
    (should (string=
             "\"ID: \"++self.id().short().substr(0,1)++label(\"id short\",\"<redacted>\")"
             (jj-template '(++ "ID: "
                               (:chain self (.id) (.short) (.substr 0 1))
                               (label "id short" "<redacted>")))))
    (should (string=
             "if(root,tidy_root_commit(self),label(if(current_working_copy,\"working_copy\"),separate(\" \",min_id,if(conflict,label(\"conflict\",\"conflict\")),content)++\"\n\"))"
             (jj-template '(if root
                               (tidy_root_commit self)
                             (label (if current_working_copy "working_copy")
                                    (++ (separate " "
                                                  min_id
                                                  (if conflict (label "conflict" "conflict"))
                                                  content)
                                        "\n"))))))
    )
#+end_src

* Templates and Structs
** Log format
#+begin_src elisp
  (eval-and-compile
    (defconst jj--count-graph-lines 4
    "Number of lines of graph to sample for each commit in the log output. Fewer lines will give scrappier output, but 4 should be enough for any graph configuration.
  I've hardcoded other areas to expect exactly 4, so changing this will not break anything but the output will change slightly, specifically in which lines are considered mandatory."))
  (eval-and-compile
    (defconst jj--major-delim "\x1E"
    "Delimiter for separating the graph from the records in the jj-log template.
    By default, this is the ascii record separator character."))
  (eval-and-compile
    (defconst jj--delim "\x1F"
    "Delimiter for separating fields in the jj-log template.
    By default, this is the ascii unit separator character."))

  (defmacro define-jj-log-format (&rest fields)
    "Define the format to be used for jj log parsing and formatting.
  Accepts a list of FIELDS in the form (NAME . PLIST), where PLIST accepts the following keys:
  - `:form' specifies the sexpression used to produce the field's log template, produced with `jj-template'. (So far there's no way to use a string template directly)
  - `:parser' specifies how to read the data in to lisp.
  - `:printer' specifies how to print the data out to a buffer. It should be a function of 2 arguments, with the first being the field and the second the entire structure.
  - `:face' specifies the face to use for formatting this entry in the log buffer. This is applied to the result of PRINTER if supplied.
  - `:separator' the separator to insert before this field, rather than a space (or empty for the first field). Only inserted if the value is present."
    `(progn
       (require 'json)
       (define-short-documentation-group jj-log
         (define-jj-log-format
          :no-manual t)
         (read-jj-log-entry
          :no-manual t)
         (insert-jj-log-entry
          :no-manual t)
         (read-jj-log-elided
          :no-manual t)
         (insert-jj-log-elided
          :no-manual t)
         (make-jj-log-entry
          :args (&key header graph)
          :no-manual t)
         (make-jj-log-graph
          :no-manual t)
         (make-jj-log-header
          :args (&key ,@(mapcar #'car fields))
          :no-manual t))
       (defvar jj-log-entry-regex
         ,(let* ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(rx line-start
                 ;; graph pre
                 (* ,content)
                 ;; graph node and suf
                 (= 2 
                    ,jj--delim
                    (* ,content))
                 (seq
                  ;; header delimiter
                  ,jj--major-delim
                  ;; header elements
                  (* ,content)
                  (= ,(1- (length fields))
                     ,jj--delim
                     (* ,content))
                  "\n"
                  ;; remaining graph
                  (= ,(1- jj--count-graph-lines)
                     (* ,content)
                     ,jj--major-delim
                     "\n"))))
         "Regex to match a full `jj-log' entry. This *should* match exactly the same content that `read-jj-log-entry' will parse.")
       (defvar jj-log-elided-regex
         ,(let* ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(rx line-start
                 ;; graph pre
                 (* ,content)
                 ;; graph node and suf
                 (= 2 
                    ,jj--delim
                    (* ,content))
                 "(elided revisions)\n"
                 ;; remaining graph
                 (* (* ,content)
                    "\n")))
         "Regex to match an elided section of `jj-log'. This *should* match exactly the same content that `read-jj-log-elided' will parse.")
       (defvar jj-parseable-template
         (jj-template '(++ ,jj--major-delim
                           (join ,jj--delim
                                 ,@(cl-loop for (name . props) in fields
                                            for form = (plist-get props :form)
                                            collect form))
                           ;; these lines only exist to get the shape of the graph
                           ;; there's already one with the header line, so count 1 fewer
                           ,@(cl-loop for n upfrom 1 below jj--count-graph-lines
                                      append `("\n" ,jj--major-delim))))
         "Commit template to produce log entries parseable by `read-jj-log-entry'.")
       (defun read-jj-log-entry ()
         "With point at the beginning of the first line of a `jj-log-parseable' entry, parse the entire entry into a `jj-log-entry' struct."
         ,(let ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(cl-loop with (graph-pre graph-node graph-suf) = (progn
                                                                (should (bolp))
                                                                (should (jj--re-step-over (rx (group (* ,content))
                                                                                              ,jj--delim
                                                                                              (group (* ,content))
                                                                                              ,jj--delim
                                                                                              (group (* ,content))
                                                                                              ,jj--major-delim)))
                                                                (list (match-string 1)
                                                                      (match-string 2)
                                                                      (match-string 3)))
                      ;; entry line
                      for (key . parser) in (list ,@(cl-loop for (name . props) in fields
                                                             for key = (intern (format ":%s" name))
                                                             for parser = (plist-get props :parser)
                                                             collect `(cons ,key ,parser)))
                      ;; no delimiter for first field
                      for first = t then nil
                      for field-rx = (rx (group (* ,content))) then (rx ,jj--delim (group (* ,content)))
                      when (jj--re-step-over field-rx)
                      nconc `(,key ,(if parser
                                        (save-match-data
                                          (funcall parser (match-string 1)))
                                      (match-string 1)))
                      into struct-props
                      finally return
                      (cl-loop initially (jj--re-step-over "\n")
                               for ix upfrom 1 below jj--count-graph-lines
                               ;; at this point, we ought to be at the start or end of a line,
                               ;; having just read either a commit or a graph-line
                               do (should (or (eolp)
                                              (bolp)))
                               if (jj--re-step-over (rx line-start
                                                        ;; since we started at eol
                                                        ;; since this starts with line-start,
                                                        ;; and matches everything up to a delimiter
                                                        ;; it's guaranteed to skip over only one character
                                                        ;; (the newline we started at)
                                                        (group (* ,content))
                                                        ,jj--major-delim
                                                        "\n"))
                               collect (match-string 1) into graph-tail
                               else return (error "failed to parse graph shape on line %d of commit %s" ix struct-props)
                               finally return (make-jj-log-entry :header (apply #'make-jj-log-header struct-props)
                                                             :graph (apply #'make-jj-log-graph graph-pre graph-node graph-suf graph-tail))))))
       (defun read-jj-log-elided ()
         "Read the graph portion of an elided section. This is just a `jj-log-graph' struct, but it's not read in the same."
         ,(let ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(cl-loop with (graph-pre graph-node graph-suf) = (progn
                                                                (should (bolp))
                                                                (should (jj--re-step-over (rx (group (* ,content))
                                                                                              ,jj--delim
                                                                                              (group (* ,content))
                                                                                              ,jj--delim
                                                                                              (group (* ,content))
                                                                                              "(elided revisions)\n")))
                                                                (list (match-string 1)
                                                                      (match-string 2)
                                                                      (match-string 3)))
                      while (jj--re-step-over (rx line-start
                                                  ;; since we started at eol
                                                  ;; since this starts with line-start,
                                                  ;; and matches everything up to a delimiter
                                                  ;; it's guaranteed to skip over only one character
                                                  ;; (the newline we started at)
                                                  (group (* ,content))
                                                  "\n")
                                              nil :noerr)
                      collect (match-string 1) into graph-tail
                      finally return (make--jj-log-graph :first-line-prefix graph-pre
                                                     :first-line-node graph-node
                                                     :first-line-suffix graph-suf
                                                     :mandatory-segments graph-tail))))
       (defun insert-jj-log-entry (entry)
         "Insert the ENTRY, formatted as a jj log entry."
         ,(cl-labels ((field (name-sym)
                        `(,(intern (format "%s-%s" 'jj-log-header name-sym))
                          header)))
            `(let ((target-buffer (current-buffer))
                   (header (jj-log-entry-header entry))
                   (graph (jj-log-entry-graph entry)))
               ;; open a buffer to make a mess in
               ;; we'll insert its contents later
               (with-temp-buffer
                 (cl-loop for (name val printer face sep) in (list ,@(cl-loop  
                                                                      for (name . props) in fields
                                                                      for first = t then nil
                                                                      for sep = (if-let ((sep (plist-get props :separator)))
                                                                                    sep
                                                                                  (cond
                                                                                   (first "")
                                                                                   (t " ")))
                                                                      for face = (plist-get props :face)
                                                                      for printer = (plist-get props :printer)
                                                                      collect `(list ',name ,(field name) ,printer ,face ,sep)))
                          do (when-let ((printed (s-presence
                                                  (if printer
                                                      (funcall printer val header)
                                                    val))))
                               (insert sep (apply #'propertize
                                                  `(,printed
                                                    help-echo ,(symbol-name name)
                                                    ,@(jj--if-arg face #'identity 'face))))))
                 ;; ensure commit text ends on a newline
                 (unless (bolp)
                   (insert "\n"))
                 ;; add field to all the commit text (including newlines)
                 ;; pointing to the header struct
                 (add-text-properties (point-min) (point-max) `(jj-object ,header))
                 ;; insert the mandatory graph prefix segments
                 ;; these will add new lines if there arent enough already
                 (cl-loop initially (progn
                                      (goto-char (point-min))
                                      (insert (jj-log-graph-first-line-prefix graph)
                                              (propertize (jj-log-graph-first-line-node graph)
                                                          'face '(:foreground "cyan")
                                                          'jj-object header)
                                              (jj-log-graph-first-line-suffix graph))
                                      (forward-line 1))
                          for (prefix . rest) on (jj-log-graph-mandatory-segments graph)
                          do (progn
                               (cond ((and
                                       ;; last nonempty mandatory segment
                                       (not (cdr rest))
                                       (not (string= "" (string-trim prefix)))
                                       ;; no repeatable segments
                                       (not (jj-log-graph-repeatable-segment graph)))
                                      (insert (propertize prefix 'face '(:foreground "grey"))))
                                     (t
                                      (insert prefix)))
                               (forward-line 1)
                               ;; while there's more mandatory graph segments, put them on new lines if you have to
                               (unless (bolp)
                                 (insert "\n"))))
                 ;; insert the repeatable graph prefix segments
                 ;; these are added to all remaining lines, but no new lines are added
                 (cl-loop with tail = (or (jj-log-graph-repeatable-segment graph)
                                          (car (last (jj-log-graph-mandatory-segments graph))))
                          while (and (bolp)
                                     (not (eobp)))
                          do (progn (insert tail)
                                    (forward-line 1)))
                 ;; insert the content of this temp buffer into the target buffer
                 ;; we can't just return it from the with-temp-buffer block,
                 ;; as by that point it's been disposed
                 (let ((content-buffer (current-buffer)))
                   (with-current-buffer target-buffer
                     (insert-buffer-substring content-buffer)))))))
       (defun insert-jj-log-elided (graph)
         "Insert the GRAPH and an \"elided revisions\" label, formatted as a jj log entry."
         (let ((target-buffer (current-buffer)))
           ;; open a buffer to make a mess in
           ;; we'll insert its contents later
           (with-temp-buffer
             (insert (propertize "(elided revisions)\n" 'face '(:foreground "grey")))
             ;; insert the mandatory graph segments
             ;; these will add new lines if there arent enough already
             (cl-loop initially (progn
                                  (goto-char (point-min))
                                  (insert (jj-log-graph-first-line-prefix graph)
                                          (propertize (jj-log-graph-first-line-node graph)
                                                      'face '(:foreground "grey"))
                                          (jj-log-graph-first-line-suffix graph))
                                  (forward-line 1))
                      for prefix in (jj-log-graph-mandatory-segments graph)
                      do (progn
                           (insert prefix)
                           (forward-line 1)
                           ;; while there's more mandatory graph segments, put them on new lines if you have to
                           (unless (bolp)
                             (insert "\n"))))
             ;; insert the content of this temp buffer into the target buffer
             ;; we can't just return it from the with-temp-buffer block,
             ;; as by that point it's been disposed
             (let ((content-buffer (current-buffer)))
               (with-current-buffer target-buffer
                 (insert-buffer-substring content-buffer))))))
       (cl-defstruct jj-log-header
         ;; semantic fields
         ,@(cl-loop for (name . props) in fields
                    collect name))))

  (cl-defstruct jj-log-entry
    "A jj log entry with commit info and graph prefixes."
    header
    graph)

  (defun make-jj-log-graph (pre node suff &rest graph-prefixes)
    "Make a jj graph struct from the given PRE NODE SUFF identifying the position of the node icon in the first line, and GRAPH-PREFIXES identifying the remainder of the graph."
    ;; figure out what part of the graph we can repeat, and what parts we can skip
    (-let* ((graph-partitioned
             (jj-partition-runs
              ;; notice edge between runs and non-runs
              graph-prefixes
              #'string=))
            ((graph-mandatory . resolved-tail)
             (pcase-exhaustive graph-partitioned
               ((and (or `(,tail-list)
                         `(,graph-mandatory ,tail-list))
                     (let `(,resolved-tail)
                       ;; only a single run of repeated elements (and they're all duplicates so only need the one)
                       (cl-remove-duplicates tail-list :test #'string=)))
                ;; either no mandatory list, or a mandatory list and a repeatable list
                ;; repeatable list is identified by being a run
                `(,graph-mandatory . ,resolved-tail))
               (`(,graph-mandatory)
                ;; no tail, so assume the repeatable list is empty. in `insert-jj-log-entry', assume the last mandatory is repeatable.
                ;; special case used to identify (and print in grey) the truncated marker of fully-separate subtrees
                ;; - this implementation is brittle AF. I really should set the truncation marker and search for it.
                `(,graph-mandatory))
               (illegal (error "I thought that jj graph output would always have at most one run in a set of `jj--count-graph-lines' lines, and that run would be at the end, but apparently not. graph segments: %s" graph-prefixes)))))
      (make--jj-log-graph
       :first-line-prefix pre
       :first-line-node node
       :first-line-suffix suff
       :mandatory-segments graph-mandatory
       :repeatable-segment resolved-tail)))

  (cl-defstruct (jj-log-graph (:constructor make--jj-log-graph))
    "Specification for the line-prefixes needed to annotate any number of commit-info lines with the graph for that region of the log."
    first-line-prefix
    first-line-node
    first-line-suffix
    mandatory-segments
    repeatable-segment)

  (defvar jj-log-node-template
    (jj-template `(++ ,jj--delim
                      (coalesce 
                       (if !self "~")
                       (if current_working_copy "@")
                       (if immutable "+")
                       (if conflict "")
                       "o")
                      ,jj--delim))
    "Node format to ensure log nodes can be parsed.")

  (define-jj-log-format
   (change-id
    :face '(:foreground "magenta")
    :form (:chain self (format_short_change_id_with_change_offset)))
   (author
    :face '(:foreground "yellow")
    :parser #'json-parse-string
    :form (:chain self (.author) (.email) (stringify) (.escape_json)))
   (timestamp
    :face '(:foreground "cyan")
    :form (:chain self (.committer) (.timestamp) (.local) (.format "%Y-%m-%d %H:%M:%S")))
   (bookmarks
    :face '(:foreground "magenta")
    :form (:chain self (.bookmarks)))
   (tags
    :face '(:foreground "yellow")
    :form (:chain self (.tags)))
   (working-copies
    :face '(:foreground "green")
    :form (:chain self (.working_copies)))
   (commit-id
    :face '(:foreground "light blue")
    :form (:chain self (.commit_id) (format_short_commit_id)))
   (conflict
    :face '(:foreground "red")
    :form (if (:chain self (.conflict)) "conflict"))
   (empty
    :face '(:foreground "green")
    :parser (lambda (s)
              (json-parse-string s :false-object nil))
    :printer (lambda (empty _entry)
               (when empty
                 "(empty)"))
    :separator "\n"
    :form (:chain self (.empty)))
   (description
    :parser #'json-parse-string
    :separator "\n"
    :printer (lambda (desc _entry)
               (or (s-presence desc)
                   (propertize "(no description)" 'face '(:foreground "orange"))))
    :form (:chain self (.description) (.escape_json))))

  (ert-deftest jj-round-trip-truncate-overflow ()
    (let ((entry (with-temp-buffer
                   
                   (insert "@  puvwmkxr\"zoeyhewll@gmail.com\"2025-12-18 18:07:32f610054a\"bic\\n*big\\nmultiline\\nmessage\\nwith\\nhonestly,\\ntoo much \\ntext\\nright here\\n\"\n  \n~  \n   \n   \n")
                   (goto-char (point-min))
                   (read-jj-log-entry))))
      (should (equal entry
                     #s(jj-log-entry
                        #s(jj-log-header "puvwmkxr"
                                     "zoeyhewll@gmail.com"
                                     "2025-12-18 18:07:32"
                                     ""
                                     ""
                                     ""
                                     "f610054a"
                                     ""
                                     "bic\n*big\nmultiline\nmessage\nwith\nhonestly,\ntoo much \ntext\nright here\n")
                        #s(jj-log-graph "" "@" "  "
                                    ("  "
                                     "~  "
                                     "   ")
                                    nil))))
      (with-temp-buffer
        (insert-jj-log-entry entry)
        (should (string= (substring-no-properties (buffer-string))
                         "@  puvwmkxr zoeyhewll@gmail.com 2025-12-18 18:07:32 f610054a\n  bic\n~  *big\n   multiline\n   message\n   with\n   honestly,\n   too much \n   text\n   right here\n"
                         )))))

  (ert-deftest jj-round-trip-truncate-underflow ()
    (let ((entry (with-temp-buffer
                   (insert "@  puvwmkxr\"zoeyhewll@gmail.com\"2025-12-18 18:07:32f610054a\"\"\n  \n~  \n   \n   \n")
                   (goto-char (point-min))
                   (read-jj-log-entry))))
      (should (equal entry
                     #s(jj-log-entry
                        #s(jj-log-header "puvwmkxr"
                                     "zoeyhewll@gmail.com"
                                     "2025-12-18 18:07:32"
                                     ""
                                     ""
                                     ""
                                     "f610054a"
                                     ""
                                     "")
                        #s(jj-log-graph "" "@" "  "
                                    ("  "
                                     "~  "
                                     "   ")
                                    nil))))
      (with-temp-buffer
        (insert-jj-log-entry entry)
        (should (string= (substring-no-properties (buffer-string))
                         "@  puvwmkxr zoeyhewll@gmail.com 2025-12-18 18:07:32 f610054a\n  \n~  \n   \n")))))

  (ert-deftest jj-round-trip-simple-underflow ()
    (let ((entry (with-temp-buffer
                   (insert "@  puvwmkxr\"zoeyhewll@gmail.com\"2025-12-18 18:07:32f610054a\"\"\n  \n  \n  \n")
                   (should (string-match-p jj-log-entry-regex (buffer-string)))
                   (goto-char (point-min))
                   (read-jj-log-entry))))
      (should (equal entry
                     #s(jj-log-entry
                        #s(jj-log-header "puvwmkxr"
                                     "zoeyhewll@gmail.com"
                                     "2025-12-18 18:07:32"
                                     ""
                                     ""
                                     ""
                                     "f610054a"
                                     ""
                                     "")
                        #s(jj-log-graph "" "@" "  "
                                    ()
                                    "  "))))
      (with-temp-buffer
        (insert-jj-log-entry entry)
        (should (string= (substring-no-properties (buffer-string))
                         "@  puvwmkxr zoeyhewll@gmail.com 2025-12-18 18:07:32 f610054a\n")))))
#+end_src
*** TODO separate graph as a first step, so log format can use generic macro
** Generic format macro
#+begin_src elisp
  (defmacro define-jj-plain-format (type-name &rest fields)
    "Define the format to be used for parsing and formatting various jj output.
  Accepts a list of FIELDS in the form (FIELD-NAME . PLIST), where PLIST accepts the following keys:
  - `:form' specifies the sexpression used to produce the field's log template, produced with `jj-template'. (So far there's no way to use a string template directly)
  - `:parser' specifies how to read the data in to lisp.
  - `:printer' specifies how to print the data out to a buffer. It should be a function of 2 arguments, with the first being the field and the second the entire structure.
  - `:face' specifies the face to use for formatting this entry in the log buffer. This is applied to the result of PRINTER if supplied.
  - `:separator' the separator to insert before this field, rather than a space (or empty for the first field). Only inserted if the value is present."
    (declare (indent 1))
    `(progn
       (require 'json)
       (define-short-documentation-group ,(intern (format "jj-%s" type-name))
         (define-jj-plain-format
             :no-manual t)
         (,(intern (format "read-jj-%s" type-name))
          :no-manual t)
         (,(intern (format "insert-jj-%s" type-name))
          :no-manual t)
         (,(intern (format "jj-%s-template" type-name))
          :no-manual t)
         (,(intern (format "make-jj-%s" type-name))
          :args (&key ,@(mapcar #'car fields))
          :no-manual t))
       (defvar ,(intern (format "jj-%s-regex" type-name))
         ,(let* ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(rx line-start
                 (seq
                  ,(format "%s" type-name)
                  ;; struct delimiter
                  ,jj--major-delim
                  ;; struct elements
                  (* ,content)
                  (= ,(1- (length fields))
                     ,jj--delim
                     (* ,content))
                  "\n")))
         ,(format "Regex to match a full `jj-%1$s' entry. This *should* match exactly the same content that `read-jj-%1$s' will parse." type-name))
       (defun ,(intern (format "jj-%s-template" type-name)) (self)
         ,(format "Get a commit template to produce entries parseable by `read-jj-%s'. SELF is the symbol to use for the self-type; usually this will just be `self', but if using the template in a lambda you may want a different type-name." type-name)
         (jj-template (cl-subst self 'self
                                '(++ ,(format "%S" type-name)
                                     ,jj--major-delim
                                     (join ,jj--delim
                                           ,@(cl-loop for (field-name . props) in fields
                                                      for form = (plist-get props :form)
                                                      collect form))
                                     ))))
       (defun ,(intern (format "read-jj-%s" type-name)) ()
         ,(format "With point at the beginning of a `jj-%1$s' entry, parse the entry into a `jj-%1$s' struct." type-name)
         ,(let ((content `(not (any ,jj--delim ,jj--major-delim "\r\n"))))
            `(cl-loop initially (with-error-context (lambda (msg)
                                                      (format "failed to read struct label %s: %s" ',type-name msg))
                                  (jj--re-step-over (rx ,(format "%s" type-name) ,jj--major-delim)))
                      for (field-name key parser) in (list ,@(cl-loop for (field-name . props) in fields
                                                             for key = (intern (format ":%s" field-name))
                                                             for parser = (plist-get props :parser)
                                                             collect `(list ',field-name ,key ,parser)))
                      ;; no delimiter for first field
                      for first = t then nil
                      for field-rx = (rx (group (* ,content))) then (rx ,jj--delim (group (* ,content)))
                      when (with-error-context (lambda (msg)
                                                 (format "failed to read field %s: %s" field-name msg))
                             (jj--re-step-over field-rx))
                      nconc `(,key ,(string-trim
                                     (if parser
                                         (save-match-data
                                           (funcall parser (match-string 1)))
                                       (match-string 1))))
                      into struct-props
                      finally return (apply #',(intern (format "make-jj-%s" type-name)) struct-props))))
       (defun ,(intern (format "insert-jj-%s" type-name)) (entry)
         ,(format "Insert the ENTRY, formatted as a `jj-%s' entry." type-name)
         ,(cl-labels ((field (name-sym)
                        `(,(intern (format "jj-%s-%s" type-name name-sym))
                          entry)))
            `(let ((target-buffer (current-buffer)))
               ;; open a buffer to make a mess in
               ;; we'll insert its contents later
               (with-temp-buffer
                 (cl-loop for (field-name val printer face sep) in (list ,@(cl-loop  
                                                                            for (field-name . props) in fields
                                                                            for first = t then nil
                                                                            for sep = (if-let ((sep (plist-get props :separator)))
                                                                                          sep
                                                                                        (cond
                                                                                         (first "")
                                                                                         (t " ")))
                                                                            for face = (plist-get props :face)
                                                                            for printer = (plist-get props :printer)
                                                                            collect `(list ',field-name ,(field field-name) ,printer ,face ,sep)))
                          do (when-let ((printed (s-presence
                                                  (if printer
                                                      (funcall printer val entry)
                                                    val))))
                               (insert sep (apply #'propertize
                                                  `(,printed
                                                    help-echo ,(symbol-name field-name)
                                                    ,@(jj--if-arg face #'identity 'face))))))
                 ;; ensure commit text ends on a newline
                 (unless (bolp)
                   (insert "\n"))
                 ;; add field to all the commit text (including newlines)
                 ;; pointing to the entry struct
                 (add-text-properties (point-min) (point-max) `(jj-object ,entry))
                 ;; insert the content of this temp buffer into the target buffer
                 ;; we can't just return it from the with-temp-buffer block,
                 ;; as by that point it's been disposed
                 (let ((content-buffer (current-buffer)))
                   (with-current-buffer target-buffer
                     (insert-buffer-substring content-buffer)))))))
       (cl-defstruct ,(intern (format "jj-%s" type-name))
         ;; semantic fields
         ,@(cl-loop for (field-name . props) in fields
                    collect field-name))))
#+end_src
** Status format
#+begin_src elisp
  (define-jj-plain-format status-lineage-entry
    (change-id
     :face '(:foreground "magenta")
     :form (:chain self (format_short_change_id_with_change_offset)))
    (commit-id
     :face '(:foreground "light blue")
     :form (:chain self (.commit_id) (format_short_commit_id)))
    (bookmarks
     :face '(:foreground "magenta")
     :form (:chain self (.bookmarks)))
    (tags
     :face '(:foreground "yellow")
     :form (:chain self (.tags)))
    (conflict
     :face '(:foreground "red")
     :form (if (:chain self (.conflict)) "conflict"))
    (description
     :parser #'json-parse-string
     :form (:chain self (.description) (.trim) (.escape_json))))

  (define-jj-plain-format status-wc-change
    (status
     :form (:chain self (.status)))
    (path-source
     :parser #'json-parse-string
     :form (:chain self (.source) (.path) (.display) (.escape_json)))
    (path-target
     :parser #'json-parse-string
     :form (:chain self (.target) (.path) (.display) (.escape_json))))

  (define-jj-plain-format status-file-conflict
    (path
     :face '(:foreground "red")
     :parser #'json-parse-string
     :form (:chain f (.path) (.display) (.escape_json)))
    ;; (num-sides) ;; todo once it's representable in a template. for now, always unknown.
    )

  (define-jj-plain-format status-file-untracked
    (path
     :face '(:foreground "magenta")
     :parser #'json-parse-string
     :form (++ (:chain self (.display t) (.escape_json)) "\n")))

  (define-jj-plain-format status-bookmark-conflict
    (name
     :face '(:foreground "magenta")
     :form (:chain self (.name) ))
    (remote
     :face '(:foreground "magenta")
     :separator "@"
     :form (++ (:chain self (.remote)) "\n")))
#+end_src
** TODO define faces rather than just setting foreground colour
* Command
** Default args
#+begin_src elisp
  (defvar jj-global-default-args
    '(;; never auto-track new files
      "--config" "snapshot.auto-track='none()'"
      ;; never colourise output
      "--color=never"
      ;; never request a pager
      "--no-pager"))
#+end_src
** Readers
#+begin_src elisp
  (defvar jj-revset-history nil "History for jj revsets")
  (defun jj-read-revset-sexp (&optional prompt)
    (when-let ((sexp (read-from-minibuffer (or prompt "revset sexp: ") nil nil nil 'jj-revset-history)))
      (unless (string= "" sexp)
        (jj-revset (read sexp)))))
  (defun jj-read-revset (&optional prompt)
    (when-let ((str (read-from-minibuffer (or prompt "revset: ") nil nil nil 'jj-revset-history)))
      (unless (string= "" str) str)))
  (defun jj-read-revision (&optional prompt revset)
    (when-let ((str (completing-read (or prompt "revision: ") (jj-match-revisions revset) nil nil nil 'jj-revset-history)))
      (unless (string= "" str) str)))

  (defvar jj-fileset-history nil "History for jj filesets")
  (defun jj-read-fileset-sexp (&optional prompt)
    (when-let ((sexp (read-from-minibuffer (or prompt "fileset sexp: ") nil nil nil 'jj-fileset-history)))
      (unless (string= "" sexp)
        (jj-fileset (read sexp)))))
  (defun jj-read-fileset (&optional prompt)
    (when-let ((str (read-from-minibuffer (or prompt "fileset: ") nil nil nil 'jj-fileset-history)))
      (unless (string= "" str) str)))
  (defvar jj-template-history nil "History for jj templates")
  (defun jj-read-template-sexp (&optional prompt)
    (when-let ((sexp (read-from-minibuffer (or prompt "template sexp: ") nil nil nil 'jj-template-history)))
      (unless (string= "" sexp)
        (jj-template (read sexp)))))
  (defun jj-read-template (&optional prompt)
    (when-let ((str (read-from-minibuffer (or prompt "template: ") nil nil nil 'jj-template-history)))
      (unless (string= "" str) str)))
#+end_src
** jj-dashboard and keybind
*** Keymaps
#+begin_src elisp
  (defvar-keymap jj-inspect-mode-map
    :parent special-mode-map
    "," #'jj-inspect-sexp-at-point
    "RET" #'jj-inspect-thing-at-point)

  (defvar-keymap jj-dashboard-mode-map
    :parent jj-inspect-mode-map
    "C-/" #'jj-undo
    "C-?" #'jj-redo
    "C-_" #'jj-undo
    "C-M-_" #'jj-redo
    "C-x u" #'jj-undo
    "c e" #'jj-edit-dwim
    "c n e" #'jj-edit-dwim
    "c n n" #'jj-new-on-dwim
    "c n -" #'jj-new-before-dwim
    "c n +" #'jj-new-after-dwim
    "c n b" #'jj-new-before-dwim
    "c n a" #'jj-new-after-dwim
    "c n i" #'jj-new-insert
    "c k" #'jj-drop-dwim
    "c w" #'jj-desc-dwim
    "c a" #'jj-amend-into-dwim
    "c s" #'jj-squash-down-dwim
    "F" #'jj-git-fetch
    "P" #'jj-git-push
    "b n" #'jj-bookmark-new-dwim
    "b m" #'jj-bookmark-move-dwim
    "b !" #'jj-bookmark-set-dwim
    "b r" #'jj-bookmark-rename
    "b d" #'jj-bookmark-delete
    "b f" #'jj-bookmark-forget
    "b t" #'jj-bookmark-track
    "b u" #'jj-bookmark-untrack
    "b l" #'jj-bookmark-list
    "b b" #'jj-new-on-bookmark
    "f t" #'jj-file-track-dwim
    "f u" #'jj-file-untrack-dwim
    "f k" #'jj-file-delete-dwim
    "$" #'jj-pop-to-command-log)

  (keymap-global-set "C-x j" #'jj-dash)
#+end_src
*** General buffer-locals
#+begin_src elisp  
  (defvar-local jj--last-revs nil
    "The revset last used in this buffer")
  (defvar-local jj--last-files nil
    "The fileset last used in this buffer")
#+end_src
*** Dashboard buffer
#+begin_src elisp
  (define-derived-mode jj-inspect-mode special-mode "jj-inspect"
    "Parent mode for most jj modes, defining basic operations")

  (define-derived-mode jj-dashboard-mode jj-inspect-mode "jj-dash"
    "Major mode for jj dashboard")

  (defvar-local jj--current-status nil
    "In a jj dashboard buffer, this is the most recent status object.")

  (defvar-local jj--indirect-buffers nil
    "Indirect buffers into the current buffer. Ought to be killed if we're reverting.")
  (defun jj-dash--revert-async (&optional and-then)
    "Asynchronously get the new status, and reverts the buffer contents when those processes complete.
  Reverted buffer is the one that was active when this function was called."
    (if-let ((dash-buf (current-buffer))
             (temp-buf (generate-new-buffer "*jj-dash-replacement*")))
        (cl-labels ((end-ok ()
                      (unwind-protect
                          (when (buffer-live-p dash-buf)
                            (with-current-buffer dash-buf
                              (let ((inhibit-read-only t))
                                (replace-buffer-contents-and-properties temp-buf))
                              (setq jj--current-status
                                    (buffer-local-value 'jj--current-status temp-buf))))
                        (cleanup)))
                    (end-err (errs)
                      (unwind-protect
                          (error "jj status update failed: %s" errs)
                        (cleanup)))
                    (cleanup ()
                      (kill-buffer temp-buf)
                      (when and-then
                        (funcall and-then))))
          (with-current-buffer temp-buf
            (start-jj-dash-async #'end-ok #'end-err)))
      (message "no jj dash buffer to update")))

  (defun jj-dash--revert (&rest _)
    ;; todo: wait on this somehow?
    (jj-dash--revert-async))

  (defun jj-dash--revert-and-goto (pred)
    (jj-dash--revert-async
     (lambda ()
       (when pred
         (jj-jump-find-object pred)))))

  (defun jj-jump-find-object (pred)
    (cl-loop for pos = (point-min) then (next-single-property-change pos 'jj-object)
             while pos
             for obj = (get-text-property pos 'jj-object)
             when (funcall pred obj) return (goto-char pos)))

  (defun jj-jump-to-thing (thing &optional test)
    (let ((test (or test #'eq)))
      (jj-jump-find-object (lambda (obj) (funcall test thing obj)))))

  (defun jj-dash-buffer (dir)
    "Return the dashboard buffer for the jj workspace root of DIR."
    (format "*jj-dash %s*" (jj-workspace-root dir)))

  ;;;###autoload
  (defun jj-dash (repo-dir)
    "Show the status of the current jj repository in a buffer."
    (interactive (list (jj-workspace-root default-directory)))
    (let ((main-buf (get-buffer-create (jj-dash-buffer repo-dir))))
      (with-current-buffer main-buf
        (jj-dashboard-mode)
        (setq-local default-directory repo-dir
                    revert-buffer-function #'jj-dash--revert)
        (start-jj-dash-blocking))
      (pop-to-buffer main-buf)))

  ;;;###autoload
  (defun jj-dash--async (repo-dir)
    "Show the status of the current jj repository in a buffer. Async - pops to the new buffer once the status is ready."
    (interactive (list (jj-workspace-root default-directory)))
    (let ((main-buf (get-buffer-create (jj-dash-buffer repo-dir))))
      (with-current-buffer main-buf
        (jj-dashboard-mode)
        (setq-local default-directory repo-dir
                    revert-buffer-function #'jj-dash--revert)
        (jj-dash--revert-async
         (lambda ()
           (pop-to-buffer main-buf))))))

  (defun jj-ensure-repo (dir)
    (let ((repo-root ((condition-case e (jj-workspace-root dir)
                        (jj-repo-missing (when (yes-or-no-p "Not within a jj repo: initialize here?")
                                           (jj-git--init-sync dir :colocate)
                                           dir)))))
      (unless (string= (expand-file-name dir)
                       (expand-file-name repo-root))
        (pcase (read-answer (format "%s is not the root of a jj repo. Continue anyway? " dir)
                            '(("yes" ?y "continue")
                              ("no" ?n "cancel")
                              ("init" ?i "initialise a repo here")))
          ("yes" t)
          ("no" (user-error "Cancelled"))
          ("init" (jj-git--init-sync dir :colocate))
          )))))

  ;;;###autoload
  (defun jj-project-dash ()
    "Run `jj-dash' in the current project's root."
    (interactive)
    (if (fboundp 'project-root)
        (jj-dash (project-root (project-current t)))
      (user-error "`jj-project-dash' requires `project' 0.3.0 or greater")))

  (defun jj-make-section-buffer (section-name &optional header trailer)
    "Make a jj section called SECTION-NAME which is narrowed down to the current value of point. Returns the buffer.
   HEADER is the text to insert before the section, and TRAILER is the text to insert after it."
    (let ((buf (clone-indirect-buffer
                (format "*jj-%s-section %s*" section-name default-directory)
                nil :norecord)))
      (prog1 buf
        (insert header)
        ;; make sure there's something between end-of-buffer and where we'll be inserting stuff
        (save-excursion
          (insert trailer)
          (push-mark nil :nomsg))
        ;; record point from the original buffer
        ;; seems there's a race condition to update it in the indirect buffer
        (let ((p (point)))
          (with-current-buffer buf
            (narrow-to-region p p)))
        ;; step over the added character
        (goto-char (mark))
        (pop-mark))))
#+end_src
*** Sections
**** jj-show for status section
the ~jj status~ command itself is not very machine-readable, but turns out i can show most of what I want from ~jj status~ via ~jj show~.
so far, the only significant differences in parity that I'm aware of, are:
- I cannot count the sides of a file conflict
- I can only show ref conflicts for the current commit, not the whole repo. but I can probably just call jj bookmark list -c for that.

#+begin_src elisp
  (defun start-jj-show-status (&optional revset fileset)
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let* ((err (generate-new-buffer "*jj-show-status-stderr*"))
           (sentinel (make-jj-simple-sentinel err))
           (filter (make-sticky-process-filter :sticky)))
      (make-process
       :name "jj-show-status"
       :buffer (current-buffer)
       :stderr err
       :filter filter
       :sentinel sentinel
       :noquery t
       :command `("jj" "show"
                  "--no-patch"
                  "-T" ,(jj-show-status-template 'self)
                  "--quiet"
                  ,@jj-global-default-args))))
#+end_src
**** COMMENT jj-show for diff section

#+begin_src elisp
  (defun start-jj-show-diff (&optional revset fileset)
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let* ((err (generate-new-buffer "*jj-show-diff-stderr*"))
           (sentinel (make-jj-simple-sentinel err))
           (filter (make-sticky-process-filter :sticky)))
      (make-process
       :name "jj-status-diff"
       :buffer (current-buffer)
       :stderr err
       :filter filter
       :sentinel sentinel
       :noquery t
       :command `("jj" "show"
                  "--no-patch"
                  "-T" ,(jj-status-diff-template 'self)
                  ,@jj-global-default-args
                  "--quiet"))))
#+end_src
**** jj-file for untracked files

#+begin_src elisp
  (defvar jj-file-untracked-regex
    (rx "? " ?\" (* nonl) ?\" "\n")
    "Regex matching a line that looks like it is a jj untracked-file entry.")

  (defun jj-file-untracked--revert (&rest _)
    (start-jj-file-untracked))

  (defun jj-file-untracked (repo-dir)
    "Run jj file list-untracked asynchronously in REPO-DIR. Returns the process and opens the corresponding buffer."
    (interactive (list (read-directory-name "jj repo: ")))
    (let* ((repo-dir (expand-file-name repo-dir))
           (buf (get-buffer-create (format "*jj-file-untracked: %s*" repo-dir))))
      (prog1
          (with-current-buffer buf
            (jj-inspect-mode)
            (setq-local default-directory repo-dir
                        revert-buffer-function #'jj-file-untracked--revert)
            (start-jj-file-untracked))
        (pop-to-buffer buf))))

  (defun start-jj-file-untracked ()
    "Make a jj file-untracked in the current buffer, without setting up modes or keymaps. For use with jj-status in an indirect buffer."
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let* ((err (generate-new-buffer "*jj-file-untracked-stderr*"))
           (sentinel (make-jj-simple-sentinel err))
           (filter (make-sticky-process-filter :sticky)))
      (make-process
       :name "jj-file-untracked"
       :buffer (current-buffer)
       :stderr err
       :filter filter
       :sentinel sentinel
       :noquery t
       :command `("jj" "file" "list-untracked"
                  "-T" ,(jj-status-file-untracked-template 'self)
                  ,@jj-global-default-args
                  "--quiet"))))
#+end_src

**** jj-bookmark-list for bookmark conflicts

#+begin_src elisp
  (defun start-jj-bookmark-list (&optional revset &rest other-args)
    "Make a jj bookmark-list in the current buffer, without setting up modes or keymaps. For use with jj-status in an indirect buffer."
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let* ((err (generate-new-buffer "*jj-bookmark-list-stderr*"))
           (sentinel (make-jj-simple-sentinel err))
           (filter (make-sticky-process-filter :sticky)))
      (make-process
       :name "jj-bookmark-list"
       :buffer (current-buffer)
       :stderr err
       :filter filter
       :sentinel sentinel
       :noquery t
       :command `("jj" "bookmark" "list"
                  ,@(jj--if-arg revset #'identity "-r")
                  ,@other-args
                  ,@jj-global-default-args
                  "--quiet"))))
#+end_src
**** TODO ensure these are distinct from similar-name commands
these section commands should be named to be sure that theydont collide with user-facing commands like jj-show for viewing a commit in its own buffer
but, they should also be able to rely on the same underlying machinery, if possible. Which would need to be flexible in templating and parsing, given the strict template used by the dash buffer.
*** Combined struct and output formatter
#+begin_src elisp
  (defun start-jj-status ()
    "Start the component processes for jj dashboard's status section. Returns the list of processes."
    (save-excursion
      (let ((procs))
        (cl-labels ((proc (proc)
                      (push proc procs)
                      proc))
          (with-current-buffer
              (jj-make-section-buffer "status" "\n" "\n")
            (proc (start-jj-show-status)))
          (with-current-buffer
              (jj-make-section-buffer "bookmark-conflicts" "\n" "\n")
            (proc (start-jj-bookmark-list
                   nil
                   "--conflicted"
                   "-T" (jj-status-bookmark-conflict-template 'self))))
          (with-current-buffer
              (jj-make-section-buffer "untracked" "\n" "\n")
            (proc (start-jj-file-untracked)))

          ;; (with-current-buffer
          ;;     (jj-make-section-buffer "diff" "Diff:\n" "\n")
          ;;   (insert "diff-content\n")
          ;;   )
          )
        procs)))

  (cl-defstruct jj-status
    "Aggregate of all of the jj status information from various command sources."
    files-untracked
    files-changed
    commit-working-copy
    commits-parent
    files-conflict
    bookmarks-conflict)

  (defun read-jj-status ()
    (cl-macrolet ((try (fn) `(jj--forgiving-read #',fn))
                  (line (&rest body) `(prog1 (progn ,@body)
                                        (unless (bolp)
                                          (forward-char 1)))))
      (make-jj-status
       :files-changed (cl-loop for entry = (line (try read-jj-status-wc-change))
                               while entry
                               collect entry)
       :commit-working-copy (line (read-jj-status-lineage-entry))
       :commits-parent (cl-loop for entry = (line (try read-jj-status-lineage-entry))
                                while entry
                                collect entry)
       :files-conflict (cl-loop for entry = (line (try read-jj-status-file-conflict))
                                while entry
                                collect entry)
       :bookmarks-conflict (cl-loop for entry = (line (try read-jj-status-bookmark-conflict))
                                    while entry
                                    collect entry)
       :files-untracked (cl-loop for entry = (line (try read-jj-status-file-untracked))
                                 while entry
                                 collect entry))))

  (defmacro slot-values (object slots)
    (declare (indent 1))
    `(with-slots ,slots ,object
       (list ,@slots)))

  (defun insert-jj-status (status)
    (with-slots (files-untracked
                 files-changed
                 commit-working-copy
                 commits-parent
                 files-conflict
                 bookmarks-conflict)
        status
      (let ((list-prefix (propertize "- " 'face '(:foreground "grey"))))
        (cond (files-changed
               (insert "Working copy changes:\n")
               (cl-loop for change in files-changed
                        for (type from to) = (slot-values change
                                               (status path-source path-target))
                        for (color . elems) = (pcase-exhaustive type
                                                ("modified" `(cyan "M" ,to))
                                                ("added" `(green "A" ,to))
                                                ("removed" `(red "D" ,from))
                                                ("copied" `(green "C" "{" ,from "=>" ,to "}"))
                                                ("renamed" `(cyan "R" "{" ,from "=>" ,to "}")))
                        do (insert list-prefix)
                        (insert (propertize (mapconcat #'identity elems " ")
                                            'face `(:foreground ,(format "%s" color))
                                            'jj-object change)
                                "\n")))
              (t (insert "Working copy unchanged\n")))
        (insert "Working copy  (@) : ")
        (insert-jj-status-lineage-entry commit-working-copy)
        (cl-loop for parent in commits-parent
                 do (insert "Parent commit (@-): ")
                 (insert-jj-status-lineage-entry parent))
        (when files-conflict
          (insert "Unresolved file conflicts:\n")
          (cl-loop for conflict in files-conflict
                   do (insert list-prefix)
                   (insert-jj-status-file-conflict conflict)))
        (when bookmarks-conflict
          (insert "Unresolved bookmark conflicts:\n")
          (cl-loop for conflict in bookmarks-conflict
                   do (insert list-prefix)
                   (insert-jj-status-bookmark-conflict conflict)))
        (when files-untracked
          (insert "Untracked files:\n")
          (cl-loop for file in files-untracked
                   do (insert list-prefix)
                   (insert-jj-status-file-untracked file))))))

  (defun jj-show-status-template (self)
    (jj-template
     (cl-subst self 'self
               `(separate "\n"
                          (:chain self
                                  (.diff)
                                  (.files)
                                  (.map (lambda (f)
                                          (:lit ,(jj-status-wc-change-template 'f))))
                                  (.join "\n"))
                          (:lit ,(jj-status-lineage-entry-template 'self))
                          (:chain self (.parents)
                                  (.map (lambda (p)
                                          (:lit ,(jj-status-lineage-entry-template 'p))))
                                  (.join "\n"))
                          (:chain self
                                  (.files)
                                  (.filter (lambda (f) (:chain f (.conflict))))
                                  (.map (lambda (f)
                                          (:lit ,(jj-status-file-conflict-template 'f))))
                                  (.join "\n"))))))

  (ert-deftest jj-test-read-status ()
    (with-temp-buffer
      (save-excursion
        (insert "status-wc-changedeleted\"hello\"\"hello\"
  status-wc-changeadded\"world\"\"world\"
  status-wc-changerenamed\"hello\"\"world\"
  status-lineage-entryzsrpuxsq/0fb53c784conflict\"diverge 1\"
  status-lineage-entryznpwrsztf55e1a64conflict\"\"
  status-file-conflict\"foo\"
  status-file-conflict\"bar\"
  status-bookmark-conflictfooorigin
  status-bookmark-conflictbar
  status-file-untracked\"file-untracked\"
  status-file-untracked\"dir-untracked/\"
  "))
      (should (equal (read-jj-status)
                     #s(jj-status
                        (#s(jj-status-file-untracked "file-untracked")
                         #s(jj-status-file-untracked "dir-untracked/"))
                        (#s(jj-status-wc-change "deleted" "hello" "hello")
                         #s(jj-status-wc-change "added" "world" "world")
                         #s(jj-status-wc-change "renamed" "hello" "world"))
                        #s(jj-status-lineage-entry "zsrpuxsq/0" "fb53c784" "" "" "conflict" "diverge 1")
                        (#s(jj-status-lineage-entry "znpwrszt" "f55e1a64" "" "" "conflict" ""))
                        (#s(jj-status-file-conflict "foo")
                         #s(jj-status-file-conflict "bar"))
                        (#s(jj-status-bookmark-conflict "foo" "origin")
                         #s(jj-status-bookmark-conflict "bar" "")))))))

  (ert-deftest jj-test-read-status-2 ()
    (with-temp-buffer
      (save-excursion
        (insert "status-wc-changemodified\"README.md\"\"README.md\"
  status-wc-changeremoved\"foo\"\"foo\"
  status-wc-changerenamed\"signal-resumable.el\"\"signal-rework-2.el\"
  status-wc-changeadded\"signal-rework.el\"\"signal-rework.el\"
  status-wc-changeadded\"world\"\"world\"
  status-lineage-entryzsrpuxsq/04f46f09c\"diverge 1\"
  status-lineage-entryznpwrsztf55e1a64conflict\"\"
  status-bookmark-conflictmain
  status-bookmark-conflictmaingit
  status-bookmark-conflictmainorigin
  status-file-untracked\"\\u001b30mesc-in-name\\u001b0m\"
  status-file-untracked\"\\u001b[30mesc-in-name\\u001b[0m\"
  status-file-untracked\"baz\"
  status-file-untracked\"newline\\nin\\nname\"
  status-file-untracked\"untracked newline\\nin\\nname\"
  "))
      (should (equal (read-jj-status)
                     #s(jj-status
                        (#s(jj-status-file-untracked "30mesc-in-name0m")
                         #s(jj-status-file-untracked "[30mesc-in-name[0m")
                         #s(jj-status-file-untracked "baz")
                         #s(jj-status-file-untracked "newline\nin\nname")
                         #s(jj-status-file-untracked "untracked newline\nin\nname"))
                        (#s(jj-status-wc-change "modified" "README.md" "README.md")
                         #s(jj-status-wc-change "removed" "foo" "foo")
                         #s(jj-status-wc-change "renamed" "signal-resumable.el" "signal-rework-2.el")
                         #s(jj-status-wc-change "added" "signal-rework.el" "signal-rework.el")
                         #s(jj-status-wc-change "added" "world" "world"))
                        #s(jj-status-lineage-entry "zsrpuxsq/0" "4f46f09c" "" "" "" "diverge 1")
                        (#s(jj-status-lineage-entry "znpwrszt" "f55e1a64" "" "" "conflict" ""))
                        ()
                        (#s(jj-status-bookmark-conflict "main" "")
                         #s(jj-status-bookmark-conflict "main" "git")
                         #s(jj-status-bookmark-conflict "main" "origin")))))))

  (ert-deftest jj-test-insert-status ()
    (with-temp-buffer
      (insert-jj-status 
       (make-jj-status
        :files-untracked
        '(#s(jj-status-file-untracked "hello")
          #s(jj-status-file-untracked "world"))
        :files-changed
        '(#s(jj-status-wc-change "removed" "hello" "hello")
          #s(jj-status-wc-change "added" "world" "world")
          #s(jj-status-wc-change "renamed" "hello" "world"))
        :commit-working-copy
        #s(jj-status-lineage-entry "zsrpuxsq/0" "fb53c784" "" "" "conflict" "diverge 1")
        :commits-parent
        '(#s(jj-status-lineage-entry "znpwrszt" "f55e1a64" "" "" "conflict" ""))
        :files-conflict
        '(#s(jj-status-file-conflict "foo")
          #s(jj-status-file-conflict "bar"))
        :bookmarks-conflict
        '(#s(jj-status-bookmark-conflict "foo" "")
          #s(jj-status-bookmark-conflict "bar" "origin"))))

      (should (string= (substring-no-properties (buffer-string))
                       "Working copy changes:
  - D hello
  - A world
  - R { hello => world }
  Working copy  (@) : zsrpuxsq/0 fb53c784 conflict diverge 1
  Parent commit (@-): znpwrszt f55e1a64 conflict
  Unresolved file conflicts:
  - foo
  - bar
  Unresolved bookmark conflicts:
  - foo
  - bar@origin
  Untracked files:
  - hello
  - world
  "))))
#+end_src
*** status piping fns
#+begin_src elisp
  (defun get-jj-status-async (callback-ok callback-err)
    "Get jj status asynchronously, e.g. to be called within a sentinel callback. Calls CALLBACK-OK with the result of `read-jj-status', or calls CALLBACK-ERR with a list of failed processes. If it finishes successfully but the buffer is killed, calls CALLBACK-ERR with the symbol `:buffer'."
    (let ((repo default-directory)
          (buf (generate-new-buffer "*jj-dash-status*")))
      (with-current-buffer buf
        (setq default-directory repo)
        (let* ((procs (start-jj-status))
               (running (seq-copy procs))
               (failed ()))
          (cl-labels ((died (proc event)
                        ;; when one process dies, mark it not running
                        (setf running (cl-delete proc running))
                        ;; maybe mark it failed
                        (unless (= (process-exit-status proc) 0)
                          (push proc failed))
                        ;; and if it was the last one, clean up.
                        (unless running
                          (cleanup)))
                      (cleanup ()
                        ;; once all processes finished, kill their buffers and call the appropriate callback
                        (mapc #'kill-buffer (mapcar #'process-buffer procs))
                        (unwind-protect
                            (cond
                             (failed
                              (funcall callback-err failed))
                             ((buffer-live-p buf)
                              (with-current-buffer buf
                                ;; need to remove empty lines so we can read-jj-status
                                (delete-matching-lines (rx line-start line-end) (point-min) (point-max))
                                (goto-char (point-min))
                                (funcall callback-ok (read-jj-status))))
                             (t
                              (funcall callback-err :buffer)))
                          ;; finally kill own output buffer
                          (kill-buffer buf))))
            (cl-loop for proc in procs
                     ;; advise each sentinel to call `died'
                     do (add-function :after (process-sentinel proc) #'died)))))))

  (defun get-jj-status-blocking ()
    "blocks to get jj status synchronously, calling `accept-process-output'. Cannot be called within a sentinel callback. this is a problem if I want to update status buffer in a sentinel."
    (let ((repo default-directory))
      (with-temp-buffer
        (setq default-directory repo)
        (save-excursion
          (let ((procs (start-jj-status)))
            (while (-any #'process-live-p procs)
              (mapc (lambda (proc)
                      (accept-process-output proc 0.0 nil :only))
                    procs))
            (mapc #'kill-buffer (mapcar #'process-buffer procs))
            (delete-matching-lines (rx line-start line-end) (point-min) (point-max))))
        (read-jj-status))))

  (defun start-jj-dash-async (callback-ok callback-err)
    "Start the jj dashboard in the current buffer, and call CALLBACK-OK once all processes finish successfully, or CALLBACK-ERR with a list of failed processes.

  Also sets `jj--current-status' in the initial buffer when the status process completes."
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let ((buf (current-buffer))
          (running ())
          (fails ()))
      (cl-labels ((cleanup ()
                    (cond (fails
                           (funcall callback-err fails))
                          (t
                           (funcall callback-ok)))))
        (with-current-buffer
            (jj-make-section-buffer "log" "Log:\n" "\n")
          (cl-labels ((died (proc event)
                        ;; when log process dies, mark it not running
                        (setf running (cl-delete proc running))
                        (unless (= (process-exit-status proc) 0)
                          (push proc fails))
                        (unless running
                          (cleanup))))
            (let ((log (start-jj-log)))
              (add-function :after (process-sentinel log)
                            #'died)
              (push log running))))
        (cl-labels ((die (&optional errs)
                      (setf running (cl-delete :status running))
                      (pcase errs
                        ('nil
                         ;; no errors
                         )
                        (:buffer
                         ;; buffer deleted
                         (push "intermediate status buffer killed"
                               fails))
                        ((pred listp)
                         ;; process errors
                         (setq fails
                               (nconc errs fails)))
                        (_
                         ;; unexpected form
                         (push `(:unexpected-form ,errs) fails))))
                    (fail (errs)
                      (die errs)
                      (unless running
                        (cleanup)))
                    (ok (stat)
                      (die)
                      (if (buffer-live-p buf)
                          (with-current-buffer buf
                            (setq-local jj--current-status stat)
                            (goto-char (point-min))
                            (let ((inhibit-read-only t))
                              (insert-jj-status stat)))
                        (push (format "dash output buffer %s deleted" buf)
                              fails))
                      (unless running
                        (cleanup))))
          (push :status running)
          (get-jj-status-async #'ok #'fail)))))

  (defun start-jj-dash-blocking ()
    "Start the jj dashboard, and block until the status section and the first part of the log are completed"
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (mapc #'kill-buffer jj--indirect-buffers)
    (setq jj--indirect-buffers nil)
    (cl-labels ((ind-buf (buffer)
                  (push buffer jj--indirect-buffers)
                  buffer))
      (save-excursion
        (let ((inhibit-read-only t)
              (log))
          (save-excursion
            ;; start async procs before waiting on main status
            
            ;; (with-current-buffer
            ;;     (indirect (jj-make-section-buffer "diff" "Diff:\n" "\n"))
            ;;   (insert "diff-content\n")
            ;;   )

            (with-current-buffer
                (ind-buf (jj-make-section-buffer "log" "Log:\n" "\n"))
              (setq log (start-jj-log))))
          
          ;; wait on main status
          (let ((stat (get-jj-status-blocking)))
            (setq-local jj--current-status stat)
            (insert-jj-status stat))
          ;; wait for first part of log output
          (accept-process-output log nil nil :only)))))
#+end_src
*** jj-log
#+begin_src elisp
  (defun jj-log--revert (&rest _)
    (start-jj-log jj--last-revs jj--last-files))

  (defun jj-log (repo-dir &optional revset fileset)
    "Run jj log asynchronously in REPO-DIR, with the given REVSET, FILESET, and TEMPLATE string arguments. Returns the process and opens the corresponding buffer."
    (interactive (list (read-directory-name "jj repo: ")
                       (jj-read-revset)
                       (jj-read-fileset)))
    (let* ((repo-dir (expand-file-name repo-dir))
           (buf (get-buffer-create (format "*jj-log: %s*" repo-dir))))
      (prog1
          (with-current-buffer buf
            (jj-inspect-mode)
            (setq-local default-directory repo-dir
                        jj--last-revs revset
                        jj--last-files fileset
                        revert-buffer-function #'jj-log--revert)
            (start-jj-log revset fileset))
        (pop-to-buffer buf))))

  (defun start-jj-log (&optional revset fileset)
    "Make a jj log in the current buffer, without setting up modes or keymaps. For use with jj-status in an indirect buffer. Ignores `jj--last-revs' and `jj--last-files'."
    (let ((inhibit-read-only t))
      (erase-accessible-buffer))
    (let* ((buf (current-buffer))
           (temp (generate-new-buffer "*jj-log-temp*"))
           (err (generate-new-buffer "*jj-log-stderr*"))
           (sentinel (make-jj-simple-sentinel err temp))
           (filter (cl-labels ((read-next ()
                                 (jj--try-read-each #'read-jj-log-entry #'read-jj-log-elided))
                               (print-entries (news)
                                 (with-current-buffer buf
                                   (let ((inhibit-read-only t))
                                     (cl-loop for new in news
                                              do (pcase new
                                                   ((pred jj-log-graph-p)
                                                    (insert-jj-log-elided new))
                                                   ((pred jj-log-entry-p)
                                                    (insert-jj-log-entry new))))))))
                     (make-jj-generic-buffered-filter temp #'read-next #'print-entries))))
      (make-process
       :name "jj-log"
       :buffer buf
       :stderr err
       :filter filter
       :sentinel sentinel
       :noquery t
       :command `("jj" "log"
                  "-T" ,jj-parseable-template
                  ,@(jj--if-arg revset #'identity "-r")
                  ,@(jj--if-arg fileset #'identity "--")
                  ,@jj-global-default-args
                  "--quiet"
                  "--config" ,(format "templates.log_node='%s'"
                                      (jj--toml-quote-string jj-log-node-template))))))
#+end_src
**** TODO delete log indirect buffer after done
tired of all these lingering jj-log-section buffers.
**** TODO new or extend macro for log node template
if log node icons are known, I can match them in the graph and colour them according to various conditions.
**** TODO it'd be great to be able to add to an existing log
like, after it's built, if I want to expand an elided section:
#+begin_quote
  @  tqqxztyu zoeyhewll@gmail.com 2025-12-24 17:03:29 main?? e7427fd1
   +  wuvynqqs zoeyhewll@gmail.com 2025-03-26 14:08:11 main?? main@origin ba86ecc3
     add basic restart-case and handler-case
   ~  (elided revisions)
   +  xpkyxvll Zoybean@users.noreply.github.com 2025-03-26 12:08:06 d825ecc5
    Initial commit
  +  zzzzzzzz 1970-01-01 08:00:00 00000000
#+end_quote

to insert the elided section:
#+begin_quote
  +  xxkpssnq zoeyhewll@gmail.com 2025-03-26 13:29:55 27cabd1d
    rename internals, move top-level to test
  +  qtuoxusn zoeyhewll@gmail.com 2025-03-26 12:08:06 4b9eaeab
    basic functionality
  ~  
#+end_quote

to produce:
#+begin_quote
  @  tqqxztyu zoeyhewll@gmail.com 2025-12-24 17:03:29 main?? e7427fd1
   +  wuvynqqs zoeyhewll@gmail.com 2025-03-26 14:08:11 main?? main@origin ba86ecc3
     add basic restart-case and handler-case
   +  xxkpssnq zoeyhewll@gmail.com 2025-03-26 13:29:55 27cabd1d
     rename internals, move top-level to test
   +  qtuoxusn zoeyhewll@gmail.com 2025-03-26 12:08:06 4b9eaeab
     basic functionality
   +  xpkyxvll Zoybean@users.noreply.github.com 2025-03-26 12:08:06 d825ecc5
    Initial commit
  +  zzzzzzzz 1970-01-01 08:00:00 00000000
#+end_quote
this will require splicing together multiple existing graph sections to augment the inserted section with the graph of the section it's being added to.
** Operations
need error handling in these. but I do like them being synchronous i think.
*** Op utils
**** find and update dash buffer
#+begin_src elisp
  (defun jj-revert-dash-buffer (dir)
    "Revert the jj dash buffer (if it exists) for DIR."
    (when-let ((buf (get-buffer (jj-dash-buffer
                                 dir))))
      (with-current-buffer buf
        (jj-dash--revert))))

  (defun jj-revert-dash-buffer-async (dir)
    "Asynchronously revert the jj dash buffer (if it exists) for DIR. Suitable for use as an async callback for process filters and sentinels."
    (when-let ((buf (get-buffer (jj-dash-buffer
                                 dir))))
      (with-current-buffer buf
        (jj-dash--revert-async))))
#+end_src

**** repo query commands
#+begin_src elisp
  (defun jj-name-list-template (self)
    (jj-template
     (cl-subst self 'self
               `(++ (:chain self
                            (.name))
                    "\n"))))

  (defun jj-bookmark-list-template (self)
    (jj-template
     (cl-subst self 'self
               `(++ (separate
                     "@"
                     (:chain self
                             (.name))
                     (:chain self
                             (.remote)))
                    "\n"))))

  (defun jj-list-bookmarks ()
    "List all bookmarks."
    (string-lines (jj-cmd-sync `("bookmark" "list"
                                 "-T" ,(jj-bookmark-list-template 'self))
                               :no-revert)
                  :omit))

  (defun jj-list-tracked-bookmarks (&optional remote)
    "List tracked bookmarks, optionally specific to a given REMOTE."
    (string-lines (jj-cmd-sync `("bookmark" "list"
                                 
                                 ,@(jj--if-arg remote #'identity "--remote")
                                 "-T" ,(jj-bookmark-list-template 'self))
                               :no-revert)
                  :omit))

  (defun jj-list-local-bookmarks (&optional tracking)
    "List local bookmarks. If TRACKING is nil, list all local bookmarks. If it is a string, list bookmarks tracking that remote. Otherwise, list bookmarks tracking any remote. "
    (let* ((tracked (and tracking
                         (not (stringp tracking))))
           (remote (and (stringp tracking)
                        tracking))
           (all (not tracking)))
      (cl-loop for line in (string-lines (jj-cmd-sync `("bookmark" "list"
                                                        ,@(jj--if-arg tracked nil "--tracked")
                                                        ,@(jj--if-arg remote #'identity "--remote")
                                                        ,@(jj--if-arg all nil "--all-remotes")
                                                        "-T" ,(jj-bookmark-list-template 'self))
                                                      :no-revert)
                                         :omit)
               unless (string-match (rx "@") line)
               collect line)))

  (defun jj-list-non-tracking-local-bookmarks ()
    "List local bookmarks that are not tracking any remote."
    (let ((all (jj-list-local-bookmarks nil))
          (tracked (jj-list-local-bookmarks :tracking)))
      (cl-set-difference all tracked :test #'equal)))

  (defun jj-list-remote-bookmarks (&optional remote tracked not-git)
    "List remote bookmarks, optionally limited to tracked, and optionally specific to a given REMOTE. If NOT-GIT, ignore the colocated git repo as a remote."
    (cl-loop for line in (string-lines (jj-cmd-sync `("bookmark" "list"
                                                      ,@(jj--if-arg tracked nil "--tracked")
                                                      ,@(jj--if-arg remote #'identity "--remote")
                                                      ,@(jj--if-arg (not (or remote tracked)) nil "--all-remotes")
                                                      "-T" ,(jj-bookmark-list-template 'self))
                                                    :no-revert)
                                       :omit)
             nconc (when (string-match (rx string-start
                                           (group (+ (not (any "\r\n @"))))
                                           "@"
                                           (group (+ (not (any "\r\n @"))))
                                           string-end)
                                       line)
                     (let-match-string ((name)
                                        (remote))
                         line
                       (unless (and not-git (string= remote "git"))
                         (list (list name remote)))))))

  (defun jj-list-untracked-remote-bookmarks (&optional remote not-git)
    "List untracked remote bookmarks, and optionally specific to a given REMOTE. If NOT-GIT, ignore the colocated git repo as a remote."
    (let ((all (jj-list-remote-bookmarks remote nil not-git))
          (tracked (jj-list-remote-bookmarks remote :tracked not-git)))
      (cl-set-difference all tracked :test #'equal)))

  (defun jj-list-git-remotes ()
    "List all git remotes."
    (mapcar (lambda (s) (string-split s " " :omit))
            (string-lines (jj-cmd-sync `("git" "remote" "list")
                                       :no-revert)
                          :omit)))

  (defun jj-match-revisions (&optional revset)
    "List all revisions matching REVSET, or all visible by default."
    (string-lines (jj-cmd-sync `("log" "--no-graph"
                                 "-r" ,(or revset "all()")
                                 "-T" ,(jj-name-list-template 'self))
                               :no-revert)
                  :omit))

  (defun jj-workspace-root (&optional dir)
    "Return the root of the jj repository containing DIR, or `default-directory' if not provided."
    (let ((default-directory (or dir default-directory)))
      (-let (((code . message) (jj-cmd-sync `("workspace" "root") :no-revert :no-error)))
        (pcase code
          (0 (s-chomp message))
          ;; this command uses code 1 to signal a missing repo. maybe all commands?
          (1 (signal 'jj-repo-missing (list default-directory)))
          (_ (error "process exited with nonzero exit code %d" res))))))

  (defalias 'assert-jj 'jj-workspace-root
    "Throw an error unless we're in a jj repo.")

  (define-error 'jj-repo-missing "Directory is not within a jj repository")
#+end_src
**** status query utils
***** revset
#+begin_src elisp
  (defun jj-get-revset-dwim (&optional prompt)
    "Get a revision or revset based on context. E.g. from around point. If no contextual value is apparent, prompt the user explicitly with PROMPT."
    (pcase (jj-thing-at-point)
      ((and cmt (pred jj-log-entry-p))
       (jj-log-header-change-id (jj-log-entry-header cmt)))
      ((and cmt (pred jj-log-header-p))
       (jj-log-header-change-id cmt))
      (unmatched (jj-read-revset prompt))))
#+end_src
***** single revision
#+begin_src elisp
  (defun jj-get-revision-dwim (&optional prompt mutable)
    "Get a revision or revset based on context. E.g. from around point. If no contextual value is apparent, prompt the user explicitly with PROMPT. If MUTABLE, only include mutable commits in the completion options."
    (pcase (jj-thing-at-point)
      ((and cmt (pred jj-log-entry-p))
       (jj-log-header-change-id (jj-log-entry-header cmt)))
      ((and cmt (pred jj-log-header-p))
       (jj-log-header-change-id cmt))
      (unmatched (jj-read-revision prompt (when mutable "~immutable()")))))
#+end_src
***** rev is wc
#+begin_src elisp

  (defun jj-rev-wc-p (rev)
    "Returns true if REV (a string) is the current working copy commit."
    (let ((stat (jj-status-commit-working-copy jj--current-status)))
      (or (equal rev (jj-status-lineage-entry-change-id stat))
          (equal rev (jj-status-lineage-entry-commit-id stat)))))

  (defun jj-obj-wc-p (obj)
    "Returns true if OBJ is the current working copy commit."
    (and (jj-log-header-p obj)
         (jj-rev-wc-p (jj-log-header-change-id obj))))
#+end_src
***** file
****** any
#+begin_src elisp

  (defun jj-get-file-dwim (&optional prompt)
    "Get a filename based on context. E.g. from around point. If no contextual value is apparent, prompt the user explicitly with PROMPT."
    (pcase (jj-thing-at-point)
      ((and file (pred jj-status-file-untracked-p))
       (jj-status-file-untracked-path file))
      ((and file (pred jj-status-wc-change-p))
       (jj-status-wc-change-path-target file))
      (unmatched (read-file-name prompt))))
#+end_src
****** untracked
#+begin_src elisp

  (defun jj-get-untracked-file-dwim (&optional prompt)
    "Get an untracked filename based on context. E.g. from around point. If no contextual value is apparent, prompt the user explicitly with PROMPT."
    (pcase (jj-thing-at-point)
      ((and file (pred jj-status-file-untracked-p))
       (jj-status-file-untracked-path file))
      (unmatched (read-file-name prompt))))
#+end_src
****** tracked
#+begin_src elisp

  (defun jj-get-tracked-file-dwim (&optional prompt)
    "Get a tracked filename based on context. E.g. from around point. If no contextual value is apparent, prompt the user explicitly with PROMPT."
    (pcase (jj-thing-at-point)
      ((and file (pred jj-status-wc-change-p))
       (jj-status-wc-change-path-target file))
      (unmatched (read-file-name prompt))))
#+end_src
***** theseus
#+begin_src elisp
  (cl-defmacro jj-compatible-ident (a b specs &optional equal)
    "Check if objects A and B can be considered equal by some means of producing an identifier. SPECS is a list of (TYPE-P GETTER) where an object matching TYPE-P can be identified by GETTER. Only the first matching type is considered. The objects need not be of the same type, they only need to produce an identifier considered equal according to EQUAL."
    (cl-labels ((get-id (ob)
                  `(cond ,@(cl-loop for (type-p getter) in specs
                                    collect `((,type-p ,ob) (list t (,getter ,ob))))
                         (t (list nil nil)))))
      `(-let (((ma id-a) ,(get-id a))
              ((mb id-b) ,(get-id b)))
         (and ma mb
              (,(or equal #'eq) id-a id-b)))))

  (defun jj-theseus-p (old new)
    "Return true if OLD and NEW (both jj objects) could refer to the same object after a modifying operation."
    (or (equal old new)
        (jj-compatible-ident old new
                             ((jj-status-wc-change-p jj-status-wc-change-path-target)
                              (jj-status-file-conflict-p jj-status-file-conflict-path)
                              (jj-status-file-untracked-p jj-status-file-untracked-path))
                             equal)
        (jj-compatible-ident old new
                             ((jj-log-header-p jj-log-header-change-id))
                             equal)
        (jj-compatible-ident old new
                             ((jj-status-lineage-entry-p jj-status-lineage-entry-change-id))
                             equal)))
#+end_src
**** thing at point
#+begin_src elisp
  (defun jj-thing-at-point ()
    (get-text-property (point) 'jj-object))

  (defun jj-inspect-sexp-at-point (thing)
    "When point is in a jj object, show that object's data in its own buffer."
    (interactive (list (jj-thing-at-point)))
    (unless thing (user-error "Not at a jj object"))
    (let ((buf (get-buffer-create "*jj-sexp*")))
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (jj--entitize-newlines (format "%S" thing)))))
      (pop-to-buffer buf)
      (special-mode)))

  (defun jj-inspect-thing-at-point (thing)
    "When point is in an inspectable jj object, show that object in its own buffer."
    (interactive (list (jj-thing-at-point)))
    (jj-inspect-thing thing))

  (cl-defgeneric jj-inspect-thing (thing)
    "Inspect THING in its own buffer if we have a method to do so."
    (user-error "Not at an inspectable jj object"))

  (cl-defmethod jj-inspect-thing ((thing jj-status-file-untracked))
    "View the file at point."
    (view-file (jj-status-file-untracked-path thing)))

  (cl-defmethod jj-inspect-thing ((thing jj-status-wc-change))
    "View the diff for the file at point."
    (jj-diff-at "@" (jj-files-as-fileset (jj-status-wc-change-path-target thing))))

  (cl-defmethod jj-inspect-thing ((thing jj-status-lineage-entry))
    "Show the change at point."
    (jj-show (jj-status-lineage-entry-commit-id thing)))

  (cl-defmethod jj-inspect-thing ((thing jj-log-header))
    "Show the change at point."
    (jj-show (jj-log-header-commit-id thing)))
#+end_src
**** swap buffers, same dir
might actually not use these as I need a lexical variable anyway in most cases where i'm following this pattern
#+begin_src elisp
  (cl-defmacro with-current-buffer-set-dir (buffer &rest body)
    "Like `with-current-buffer', but sets the `default-directory' in BUFFER to whatever is current at the call site. Does not let-bind `default-directory' - it is set persistently."
    (let ((dir-sym (gensym "buffer")))
      `(let* ((,dir-sym default-directory))
         (with-current-buffer ,buffer
           (setq-local default-directory ,dir-sym)
           ,@body))))

  (cl-defmacro with-current-buffer-let-dir (buffer &rest body)
    "Like `with-current-buffer', but let-binds the `default-directory' in BUFFER for the duration of BODY to whatever is current at the call site."
    (let ((dir-sym (gensym "buffer")))
      `(let* ((,dir-sym default-directory))
         (with-current-buffer ,buffer
           (let ((default-directory ,dir-sym))
             ,@body)))))
#+end_src
*** Sync commands
**** sync command utils
#+begin_src elisp
  (defun jj-cmd-sync (cmd &optional no-revert no-error)
    "Call jj with the given CMD, passing the default args first, and returning the output as a string. Signals an error if the command returns a nonzero exit code. When the command completes successfully, reverts the dash buffer for the repo (if there is one, and NO-REVERT was nil).
  When NO-ERROR, return the error code instead of raising an error. See `call-cmd' for details."
    (let ((cmd `("jj" ,@jj-global-default-args ,@cmd)))
      (prog1
          (call-cmd cmd nil :string nil no-error)
        (unless no-revert
          (jj-revert-dash-buffer default-directory)))))
#+end_src
**** view
***** jj bookmark list
#+begin_src elisp
  (defun jj-bookmark-list ()
    (interactive)
    (message "%s"
             (s-chomp
              (jj-cmd-sync `("bookmark" "list")
                           :no-revert))))
#+end_src
*** Async commands
**** command log
#+begin_src elisp
  (defun jj-pop-to-command-log (repo-dir)
    "Open the command-log buffer for the current repo."
    (interactive (list default-directory))
    (pop-to-buffer (jj--get-command-log-buf repo-dir)))

  (defun jj--get-command-log-buf (repo-dir)
    "Get or create the command-log buffer for the given REPO-DIR, and ensure it is in the correct mode."
    (let ((buf (get-buffer-create (format "*jj-command-log:%s*" (expand-file-name repo-dir)))))
      (with-current-buffer buf
        (unless (derived-mode-p 'jj-inspect-mode)
          (jj-inspect-mode)))
      buf))
#+end_src
**** async command utils
#+begin_src elisp
  (defalias 'jj-cmd-async 'jj-cmd-promise)

  (defun jj-cmd-promise (name cmd &optional no-revert silent-ok no-kill-output)
    "Run CMD asynchronously, returning a promise of its completion.

  On success, reverts the repo's dash buffer unless NO-REVERT, prints a message unless SILENT-OK, kills the output buffer unless NO-KILL-OUTPUT, and returns the process. On error, prints a message indicating the command log buffer, and returns a cons (PROCESS . EVENT)."
    (declare (indent 2))
    (promise-then
     (jj-cmd--promise name cmd)
     (jj--make-async-success-callback name no-revert silent-ok no-kill-output)
     (jj--make-async-failure-callback name)))

  (defun jj--make-async-success-callback (name &optional no-revert silent-ok no-kill-output)
    (lambda (proc)
      (unless no-revert
        (jj-revert-dash-buffer-async
         (buffer-local-value 'default-directory
                             (process-buffer proc))))
      (unless silent-ok
        (message "`jj %s' ok" name))
      (unless no-kill-output
        (kill-buffer (process-buffer proc)))
      proc))

  (defun jj--make-async-failure-callback (name)
    (-lambda ((proc . event))
      (message "`jj %s' failed. Type %s to see logs" name (substitute-command-keys "\\[jj-pop-to-command-log]"))))

  (defun jj-cmd--promise (name cmd)
    "Run CMD asynchronously, returning a promise that is resolved (returning the process) on completion."
    (declare (indent 2))
    (let ((repo-dir default-directory))
      (-let (((code stdout . stderr) (jj--make-process-log-section-buffers name cmd)))
        (promise-new
         (lambda (resolve reject)
           (let ((proc (make-process
                        :name (format "jj-%s" name)
                        :buffer stdout
                        :stderr stderr
                        :sentinel (jj--make-update-exit-code-sentinel code)
                        :noquery t
                        :command `("jj"
                                   ,@jj-global-default-args
                                   ,@cmd))))
             (jj--set-initial-run-status code)
             (add-function :after (process-sentinel proc)
                           (jj--make-print-status-sentinel stderr))
             (add-function :after (process-sentinel proc)
                           (make-jj-callback-sentinel
                            (lambda (code event)
                              (if (eq code 0)
                                  (funcall resolve proc)
                                (funcall reject (cons proc event))))))
             ;; this always runs before the subsequent callbacks,
             ;; which means `resolve' and `reject' are not themselves callbacks
             (add-function :after (process-sentinel proc)
                           (jj--make-cleanup-sentinel stderr code))))))))
#+end_src
**** view
***** util
#+begin_src elisp
  (defun jj--make-async-copy-cleanup-pop-callback (to-buf)
    "For jj commands which open up a new output buffer, make a callback to copy from the process buffer into TO-BUF,
  then kill the process buffer and pop to TO-BUF."
    (lambda (proc)
      (with-current-buffer to-buf
        (let ((inhibit-read-only t))
          (replace-buffer-contents (process-buffer proc)))
        (kill-buffer (process-buffer proc)))
      (pop-to-buffer to-buf)))
#+end_src
***** jj diff
#+begin_src elisp
  (cl-defun jj-diff (&key at from to fileset)
    "View the diff for AT, or between FROM and TO, optionally limited to files in FILESET."
    (let* ((repo-dir default-directory)
           (main-buf (get-buffer-create (format "*jj-diff %s:%s:%s*" repo-dir at fileset))))
      (with-current-buffer main-buf
        (diff-mode)
        (view-mode-enter nil #'kill-buffer)
        (setq-local default-directory repo-dir)
        (let ((inhibit-read-only t))
          (erase-accessible-buffer)))
      (promise-then
       (jj-cmd-async
           "diff"
           `("diff"
             "--git"
             ,@(jj--if-arg at #'identity "--revisions")
             ,@(jj--if-arg from #'identity "--from")
             ,@(jj--if-arg to #'identity "--to")
             "--"
             ,@(jj--if-arg fileset #'identity nil))
         :no-revert :silent-ok :no-kill-output)
       (jj--make-async-copy-cleanup-pop-callback main-buf))))

  (defun jj-diff-at (revset &optional fileset)
    "View the diff for REVISION, optionally limited to files in FILESET."
    (jj-diff :at revset :fileset fileset))

  (defun jj-diff-from-to (from to &optional fileset)
    "View the diff between FROM and TO, optionally limited to files in FILESET."
    (jj-diff :from from :to to :fileset fileset))
#+end_src
***** jj show
#+begin_src elisp
  (cl-defun jj-show (commit &optional fileset)
    "View COMMIT, optionally limited to files in FILESET."
    (let* ((repo-dir default-directory)
           (main-buf (get-buffer-create (format "*jj-show %s:%s:%s*" repo-dir commit fileset))))
      (with-current-buffer main-buf
        ;; TODO get a better mode for full commit view
        (diff-mode)
        (view-mode-enter nil #'kill-buffer)
        (setq-local default-directory repo-dir)
        (let ((inhibit-read-only t))
          (erase-accessible-buffer)))
      (promise-then
       (jj-cmd-async
           "diff"
           `("show"
             "--git"
             "-r" ,commit
             "--"
             ,@(jj--if-arg fileset #'identity nil))
         :no-revert :silent-ok :no-kill-output)
       (jj--make-async-copy-cleanup-pop-callback main-buf))))

#+end_src
**** do
***** jj undo
#+begin_src elisp
  (cl-defun jj-undo ()
    (interactive)
    (jj-cmd-async "undo" `("undo") nil :silent-ok))
#+end_src
***** jj redo
#+begin_src elisp
  (cl-defun jj-redo ()
    (interactive)
    (jj-cmd-async "redo" `("redo") nil :silent-ok))
#+end_src
***** jj new
#+begin_src elisp
  (cl-defun jj-new (&key rev before after message no-edit)
    (when (and rev (or before after))
      (user-error "cannot supply REV with BEFORE or AFTER"))
    (unless (or rev before after)
      (user-error "must supply at least one of REV, BEFORE, or AFTER"))
    (jj-cmd-async "new"
        `("new"
          ,@(jj--if-arg rev #'identity "-r")
          ,@(jj--if-arg before #'identity "--before")
          ,@(jj--if-arg after #'identity "--after")
          ,@(jj--if-arg no-edit nil "--no-edit")
          ,@(jj--if-arg message #'identity "-m"))
      nil :silent-ok))

  (cl-defun jj-new-on-dwim (parents-revset &key message no-edit)
    "Create a new commit after the chosen PARENTS-REVSET, with no children."
    (interactive (list (jj-get-revset-dwim "parent revs: ")))
    (jj-new :rev parents-revset :message message :no-edit no-edit))

  (cl-defun jj-new-on-bookmark (bookmark-name &key message no-edit)
    "Create a new commit after the chosen BOOKMARK-NAME, with no children."
    (interactive (list (completing-read "New on bookmark: " (jj-list-bookmarks))))
    (jj-new :rev bookmark-name :message message :no-edit no-edit))

  (cl-defun jj-new-before-dwim (children-revset &key message no-edit)
    "Insert a new commit before the chosen CHILDREN-REVSET, and after its parents."
    (interactive (list (jj-get-revset-dwim "child revs: ")))
    (jj-new :before children-revset :message message :no-edit no-edit))

  (cl-defun jj-new-after-dwim (parents-revset &key message no-edit)
    "Insert a new commit after the chosen PARENTS-REVSET, and before its children."
    (interactive (list (jj-get-revset-dwim "parent revs: ")))
    (jj-new :after parents-revset :message message :no-edit no-edit))

  (cl-defun jj-new-insert (children-revset parents-revset &key message no-edit)
    "Insert a new commit before the chosen CHILDREN-REVSET, and after the chosen PARENTS-REVSET."
    (interactive (list (jj-read-revset "parent revs: ")
                       (jj-read-revset "child revs: ")))
    (jj-new :before children-revset :after parents-revset :message message :no-edit no-edit))
#+end_src
***** jj edit
#+begin_src elisp
  (cl-defun jj-edit-dwim (rev &optional ignore-immutable)
    (interactive (list (jj-get-revset-dwim "edit: ")))
    (jj-cmd-async "edit"
        `("edit"
          "-r" ,rev
          ,@(jj--if-arg ignore-immutable nil "--ignore-immutable"))
      nil :silent-ok))
#+end_src
***** jj desc
#+begin_src elisp
  (defun jj-desc-dwim (revset message)
    (interactive (list (jj-get-revset-dwim "revs to describe: ")
                       (read-string "message: ")))
    (jj-cmd-async "describe"
        `("describe"
          "-r" ,revset
          "-m" ,message)
      nil :silent-ok))
#+end_src
***** jj drop
#+begin_src elisp
  (defun jj-drop-dwim (revset &optional noconfirm)
    (interactive (list (jj-get-revset-dwim "revs to abandon: ")))
    (unless (or noconfirm (yes-or-no-p (format "abandon %s?" revset)))
      (user-error "cancelled"))
    (jj-cmd-async "abandon"
        `("abandon"
          "-r" ,revset)
      nil :silent-ok))
#+end_src
***** jj git init
#+begin_src elisp
  ;;;###autoload
  (defun jj-git-init (root-dir colocate)
    (interactive (list (expand-file-name (read-directory-name "repository root: "))
                       (yes-or-no-p "colocated repository?")))
    (jj-cmd-async "init"
        `("git" "init"
          ,@(jj--if-arg colocate nil "--colocate")
          "--" ,root-dir)
      (lambda (ok _dir)
        (when ok
          (jj-dash--async root-dir))
        (unless ok
          (message "jj init failed")))))

  (defun jj-git--init-sync (root-dir colocate)
    (interactive (list (expand-file-name (read-directory-name "repository root: "))
                       (yes-or-no-p "colocated repository?")))
    (jj-cmd-sync
        `("git" "init"
          ,@(jj--if-arg colocate nil "--colocate")
          "--" ,root-dir)
        :no-revert))
#+end_src
***** jj bookmark
****** new
#+begin_src elisp
  (defun jj-bookmark-new-dwim (bookmark rev)
    "Create new BOOKMARK pointing at revision REV."
    (interactive (list (read-string "New bookmark: ")
                       (jj-get-revision-dwim "At rev: ")))
    (jj-cmd-async "bookmark-create"
        `("bookmark" "create" ,bookmark
          "-r" ,rev)
      nil :silent-ok))
#+end_src
****** move
#+begin_src elisp
  (defun jj-bookmark-move-dwim (bookmark to-rev &optional allow-backwards)
    "Move BOOKMARK to point to revision TO-REV. If used with a prefix arg, allow the bookmark to move backwards or sideways."
    (interactive (list (completing-read "Move bookmark: " (jj-list-local-bookmarks))
                       (jj-get-revision-dwim "move to: ")
                       current-prefix-arg))
    (jj-cmd-async "bookmark-move"
        `("bookmark" "move" ,bookmark
          "--to" ,to-rev
          ,@(jj--if-arg allow-backwards nil "--allow-backwards"))
      nil :silent-ok))
#+end_src
****** set
#+begin_src elisp
  (defun jj-bookmark-set-dwim (bookmark rev &optional allow-backwards)
    "Create or move BOOKMARK to point to revision REV. If used with a prefix arg, allow the bookmark to move backwards or sideways.

  Can be used to recreate a deleted bookmark, unlike `jj-bookmark-move-dwim' and `jj-bookmark-new-dwim'."
    (interactive (list (completing-read "Set bookmark: " (jj-list-local-bookmarks))
                       (jj-get-revision-dwim "Set to: ")
                       current-prefix-arg))
    (jj-cmd-async "bookmark-set"
        `("bookmark" "set" ,bookmark
          "-r" ,rev
          ,@(jj--if-arg allow-backwards nil "--allow-backwards"))
      nil :silent-ok))
#+end_src
****** rename
#+begin_src elisp
  (defun jj-bookmark-rename (bookmark new-name)
    "Create new BOOKMARK pointing at revision REV."
    (interactive (list (completing-read "Rename bookmark: " (jj-list-bookmarks))
                       (read-string "New name: ")))
    (jj-cmd-async "bookmark-rename"
        `("bookmark" "rename" ,bookmark ,new-name)
      nil :silent-ok))
#+end_src
****** delete
#+begin_src elisp
  (defun jj-bookmark-delete (bookmark &optional noconfirm)
    "Delete BOOKMARK."
    (interactive (list (completing-read "Delete bookmark: " (jj-list-bookmarks))
                       current-prefix-arg))
    (unless (or noconfirm (yes-or-no-p (format "delete bookmark %s?" bookmark)))
      (user-error "cancelled"))
    (jj-cmd-async "bookmark-delete"
        `("bookmark" "delete" ,bookmark)
      nil :silent-ok))
#+end_src
****** forget
#+begin_src elisp
  (defun jj-bookmark-forget (bookmark &optional noconfirm)
    "Delete BOOKMARK, but don't mark it for deletion on the remote."
    (interactive (list (completing-read "Forget bookmark: " (jj-list-bookmarks))
                       current-prefix-arg))
    (unless (or noconfirm (yes-or-no-p (format "forget bookmark %s?" bookmark)))
      (user-error "cancelled"))
    (jj-cmd-async "bookmark-forget"
        `("bookmark" "forget" ,bookmark)
      nil :silent-ok))
#+end_src
****** track
#+begin_src elisp
  (defun jj-bookmark-track (remote bookmark)
    "Track BOOKMARK at REMOTE."
    (interactive (let ((bookmark (completing-read "Bookmark to track: " (jj-list-bookmarks)))
                       (remote (completing-read "From remote: " (jj-list-git-remotes))))
                   (list remote bookmark)))
    (jj-cmd-async "bookmark-track"
        `("bookmark" "track" ,bookmark
          "--remote" ,remote)
      nil :silent-ok))

  (defun jj-bookmark-track-remote (remote bookmark)
    "Track BOOKMARK which is from REMOTE. Only prompts for untracked bookmarks at the given REMOTE."
    (declare (interactive-only jj-bookmark-track))
    (interactive (let ((remote (completing-read "From remote: " (jj-list-git-remotes)))
                       (bookmark (completing-read "Bookmark to track: " (jj-list-untracked-remote-bookmarks nil :not-git))))
                   (list remote bookmark)))
    (jj-cmd-async "bookmark-track"
        `("bookmark" "track" ,bookmark
          "--remote" ,remote)
      nil :silent-ok))

  (defun jj-bookmark-track-local (remote bookmark)
    "Track local BOOKMARK on REMOTE. Only prompts for local bookmarks."
    (declare (interactive-only jj-bookmark-track))
    (interactive (let ((bookmark (completing-read "Bookmark to track: " (jj-list-local-bookmarks)))
                       (remote (completing-read "To remote: " (jj-list-git-remotes))))
                   (list remote bookmark)))
    (jj-cmd-async "bookmark-track"
        `("bookmark" "track" ,bookmark
          "--remote" ,remote)
      nil :silent-ok))

#+end_src

****** untrack
#+begin_src elisp
  (defun jj-bookmark-untrack (bookmark &optional remotes)
    "Untrack BOOKMARK from REMOTES if provided, otherwise all remotes."
    (interactive (let* ((bookmarks (jj-list-remote-bookmarks nil :tracked :not-git))
                        (bookmark (completing-read "Bookmark to untrack: " (mapcar #'car bookmarks) nil t))
                        (remotes (completing-read-multiple
                                  "From remotes: "
                                  (cl-loop for (b r) in bookmarks
                                           when (string= b bookmark)
                                           collect r)
                                  nil t)))
                   (list bookmark remotes)))
    (jj-cmd-async "bookmark-untrack"
        `("bookmark" "untrack" ,bookmark
          ,@(jj--if-arg remotes (apply-partially #'apply #'jj-revs-as-revset) "--remote"))
      nil :silent-ok))
#+end_src
***** jj file
****** track
#+begin_src elisp
  (defun jj-file-track-dwim (file)
    "Track FILE."
    (interactive (list (jj-get-untracked-file-dwim "File to track")))
    (jj-cmd-async "file-track"
        `("file" "track" ,(jj-files-as-fileset file))
      nil :silent-ok))
#+end_src
****** untrack
#+begin_src elisp
  (defun jj-file-untrack-dwim (file)
    "Untrack FILE."
    (interactive (list (jj-get-tracked-file-dwim "File to untrack")))
    (jj-cmd-async "file-untrack"
        `("file" "untrack" ,(jj-files-as-fileset file))
      nil :silent-ok))
#+end_src
****** delete
#+begin_src elisp
  (defun jj-file-delete-dwim (file &optional noconfirm)
    "Delete FILE."
    (interactive (list (jj-get-file-dwim "File to untrack")
                       current-prefix-arg))
    (unless (or noconfirm (yes-or-no-p (format "delete file %s?" file)))
      (user-error "cancelled"))
    (jj-cmd-async "rm"
        `("util" "exec" "rm" ,file)
      nil :silent-ok))
#+end_src
***** jj squash/amend
#+begin_src elisp
  (cl-defun jj-squash-down-dwim (rev &optional noconfirm ignore-immutable)
    "Squash changes from REV into its single parent."
    (interactive (list (jj-get-revision-dwim "squash rev: ")
                       nil
                       current-prefix-arg))
    (unless (or noconfirm (yes-or-no-p (format "squash %s into its parent?" rev)))
      (user-error "cancelled"))
    (with-editor "VISUAL"
      (jj-cmd-async "squash"
          `("squash"
            "-r" ,rev
            ,@(jj--if-arg ignore-immutable nil "--ignore-immutable"))
        nil :silent-ok)))

  (cl-defun jj-amend-into-dwim (rev &optional noconfirm ignore-immutable)
    "Squash changes from @ into the chosen revision."
    (interactive (list (jj-get-revision-dwim "squash into rev: ")
                       nil
                       current-prefix-arg))
    (unless (or noconfirm (yes-or-no-p (format "squash @ into %s?" rev)))
      (user-error "cancelled"))
    (with-editor "VISUAL"
      (jj-cmd-async "squash"
          `("squash"
            "--into" ,rev
            ,@(jj--if-arg ignore-immutable nil "--ignore-immutable"))
        nil :silent-ok)))
#+end_src
***** jj split
Full-interactive split will require an interactive hunk selector. Maybe just use magit for this?
***** jj git push
#+begin_src elisp
  (defun jj-git-push ()
    "Push to git in the background."
    (interactive)
    (jj-cmd-async "git-push" `("git" "push")))
#+end_src

***** jj git fetch
#+begin_src elisp
  (defun jj-git-fetch ()
    "Fetch from git in the background."
    (interactive)
    (jj-cmd-async "git-fetch" `("git" "fetch")))
#+end_src

* Provide
#+begin_src elisp
  (provide 'majjik)
#+end_src
* Package footer
#+begin_src elisp :comments no
  ;;; majjik.el ends here
#+end_src
